{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CAM-SIMA developer documentation","text":""},{"location":"atmospheric_physics/Tagging-Instructions/","title":"How to properly tag an atmospheric_physics commit","text":"<p>This page lists instructions for how to create a new atmospheric_physics tag.  A few rules:</p> <ol> <li>Tags should always be annotated (no lightweight tags).</li> <li>Tags should follow the naming convention listed below.</li> <li>All merge commits into the main branch should be tagged.</li> <li>Tags can only be created by people who have write access.</li> </ol>"},{"location":"atmospheric_physics/Tagging-Instructions/#how-to-create-a-git-tag-via-the-command-line","title":"How to create a git tag via the command line","text":"<p>You can create a new atmospheric_physics tag, assuming you have git installed on your local machine, by doing the following:</p> <p>1.  Download the latest version of the repo:</p> <pre><code>git clone https://github.com/ESCOMP/atmospheric_physics.git\ncd atmospheric_physics\n</code></pre> <p>If you are tagging a development commit, then also make sure to checkout the development branch:</p> <pre><code>git checkout development\n</code></pre> <p>2.  Find the commit hash you want to tag.  This can be done by opening the git log like so:</p> <p><code>git log</code></p> <p>And finding the commit hash you are tagging, along with the commit message.  If you simply want to tag the head of the repo (i.e. the latest commit), then do:</p> <p><code>git log --oneline -1</code></p> <p>And use the provided hash and message.</p> <p>3.  Create the tag:</p> <p><code>git tag -a &lt;tag&gt; &lt;commit_hash&gt; -m '&lt;commit_message&gt;'</code></p> <p>Where <code>&lt;tag&gt;</code> is the new tag name (which should follow the naming convention shown below), <code>commit_hash</code> is the commit hash you found in step 2, and <code>commit_message</code> is the message/description associated with that commit.</p> <p>4.  Push the new tag back to the repo:</p> <p><code>git push origin &lt;tag&gt;</code></p> <p>After which the new tag should now exist in the ESCOMP/atmospheric_physics repo.</p>"},{"location":"atmospheric_physics/Tagging-Instructions/#tag-naming-conventions","title":"Tag naming conventions","text":"<p>All ESCOMP/atmospheric_physics tags for the main branch should look like the following:</p> <p><code>atmos_physX_YY_ZZZ</code></p> <p>While all tags for the development branch should be:</p> <p><code>dev_atmos_physX_YY_ZZZ</code></p> <p>Where <code>X</code> is the major release version (which should almost always be left as-is), <code>YY</code> is for whenever a new physics scheme or suite is added, and <code>zz</code> is for any other minor release/bug fix.</p> <p>So, for example, if the latest tag is:</p> <p><code>atmos_phys0_05_025</code></p> <p>And you want to tag a new commit that fixed a bug, then the new tag should be:</p> <p><code>atmos_phys0_05_026</code></p> <p>However, if you instead added an entirely new physics scheme to the repo, then the new tag should be:</p> <p><code>atmos_phys0_06_000</code></p> <p>Hope that helps, and good luck with tagging!</p>"},{"location":"atmospheric_physics/development_workflow/","title":"Development workflow for atmospheric_physics","text":"<p>This page describes the general workflow for adding new developments to the atmospheric_physics repo, which is the location of all CGD-developed CCPP-ized physics schemes and Suite Definition Files (SDFs).</p>"},{"location":"atmospheric_physics/development_workflow/#workflow-summary","title":"Workflow summary","text":"<p>The general workflow for adding a feature, bug-fix, or modification to atmospheric_physics is as follows:</p> <ol> <li>Open an issue.</li> <li>Add your code modifications to a branch on your fork.</li> <li>Add/amend unit tests</li> <li>Open a PR from your branch to the <code>development</code> branch.</li> <li>Respond to any reviewer requests.</li> <li>Fix any failing automated Github tests.</li> <li>If moving code from CAM to atmospheric_physics, diff CAM between the latest tag and the tag where work was branched off from to verify that the moved code did not have any changes while work was being done. For example, <code>git diff --name-status cam6_4_xxx...cam6_4_yyy</code> and check if any files related to the atmospheric_physics PR have (unexpectedly) changed.</li> <li>RECOMMENDED: Rerun CAM and/or CAM-SIMA regression tests to ensure your updates haven't broken anything.</li> <li>Update <code>doc/NamesNotInDictionary.txt</code> file.</li> <li>If you know that this PR will need an official tag, then also add the tag name to the PR description.</li> <li>If this PR contains updates that will impact CAM, DO NOT MERGE the PR until you have been assigned a CAM tag by the CAM gatekeeper<ul> <li>If there are associated changes to CAM-SIMA, it is also good practice to get those changes approved before merging the atmospheric_physics PR.</li> </ul> </li> <li>Once you're ready to merge, squash the commits and merge the PR (e.g. the \"squash and merge\" option).</li> </ol> <p>If you need an official tag for your new additions, then once your <code>development</code> PR has been merged you will need to do the following:</p> <ol> <li>Open a PR that merges the atmospheric_physics <code>development</code> branch into <code>main</code>.  Ensure that the PR description lists the title and number of every PR that went into <code>development</code> since the last update to <code>main</code>.</li> <li>Fix any failing tests.  This includes tests on the target host models that will be using the new tag.</li> <li>Merge (do not squash!) the PR.</li> <li>Tag the new merge commit.</li> </ol>"},{"location":"atmospheric_physics/development_workflow/#workflow-details","title":"Workflow details","text":"<p>The following sections describe various workflow actions in more detail.</p>"},{"location":"atmospheric_physics/development_workflow/#1-open-an-issue","title":"1.  Open an issue.","text":"<p>It is generally recommended to open an issue for any new feature that will be added or bug that has been found that will need to be fixed.  There is currently no official requirement on what should be contained within the issue text, so generally just put any information you think might be relevant.</p>"},{"location":"atmospheric_physics/development_workflow/#2-create-a-fork-if-you-havent-already","title":"2.  Create a fork (if you haven't already).","text":"<p>We recommend creating a fork of the atmospheric_physics repo, and doing all of the development there.  Instructions for how to set up a fork, and how to configure git in general, can be found here.</p>"},{"location":"atmospheric_physics/development_workflow/#3-update-your-code-with-changes-from-the-official-repo","title":"3. Update your code with changes from the official repo.","text":"<p>1.  Clone your repo and add an upstream remote</p> <pre><code>   git clone https://github.com/&lt;GitHub userid&gt;/atmospheric_physics\n   cd atmospheric_physics\n   git remote add upstream https://github.com/ESCOMP/atmospheric_physics.git\n</code></pre> <p>2.  Fetch the latest version of the ESCOMP repo:</p> <pre><code>   git fetch upstream\n</code></pre> <p>3.  Rebase your local forked branch to the ESCOMP version.  For example, assuming you are working on a local branch called <code>feature</code>:</p> <pre><code>   git checkout feature\n   git rebase upstream/development\n</code></pre> <p>Please note that you may also do a <code>git merge upstream/development</code> if you feel more comfortable with that method.</p> <p>If you then want to update the <code>feature</code> branch on your Github fork, then push your changes like so:</p> <p>rebase:</p> <pre><code>   git push -f\n</code></pre> <p>merge:</p> <pre><code>   git push\n</code></pre> <p>Of course, if you run into any problems with either method then please create a discussion post that contains your message and someone will try and assist you.</p>"},{"location":"atmospheric_physics/development_workflow/#4-committing-code","title":"4. Committing code","text":"<p>1. Create a new branch off of the ESCOMP development branch:</p> <pre><code>   git checkout -b cool_new_feature upstream/development\n</code></pre> <p>where <code>cool_new_feature</code> is an example branch name (you can use any name you want).  Next, push that new branch to your fork on Github:</p> <pre><code>   git push -u origin cool_new_feature\n</code></pre> <p>2.  Apply your code modifications and/or script additions, and perform at least one test making sure that your modifications work as expected.</p> <p>3.  Add all the files that you want to commit.  There are multiple ways to do this, but one of the safer ways is to first check your status:</p> <pre><code>   git status\n</code></pre> <p>This will provide a list of all modified files.  For each one of those files whose modifications you want to add to the main package, you will do the following:</p> <pre><code>   git add awesome_scheme.meta\n</code></pre> <p>Where <code>awesome_script.meta</code> should be replaced with whatever your file name is.  Do this for each file you want to include.  If you are confident that every file listed by <code>git status</code> needs to be added, then you can do it all at once by doing:</p> <pre><code>   git add -A\n</code></pre> <p>You can then type <code>git status</code> again, at which point all of the files you added should be \"staged\" for commit.</p> <p>4.  Commit your changes to your local branch:</p> <pre><code>   git commit -m \"&lt;message&gt;\"\n</code></pre> <p>where <code>&lt;message&gt;</code> is a short descriptor or sentence stating what the commits are for, e.g. \"Fixed color bar bug\" or \"Added significance hatching\".</p> <p>5.  Push your committed changes to your fork:</p> <pre><code>   git push\n</code></pre>"},{"location":"atmospheric_physics/development_workflow/#5-unit-testing","title":"5. Unit Testing","text":"<p>Also make sure that the unit tests all pass and verify if your changes can be unit tested and added to the test suite. </p> <p>Atmospheric_physics uses pFUnit as the toolkit for unit testing Fortran codes.  It is similar to googletest in providing an explicit interface/setup procedure to make it clear what you are testing and how.</p>"},{"location":"atmospheric_physics/development_workflow/#running-the-unit-test-suite","title":"Running the unit test suite","text":"<p>To run the tests, you will need to build pFUnit manually (see either the github workflow for atmospheric_physics or the pFUnit documentation on how to build) and then use that to build the tests:</p> <pre><code>$ cmake -DCMAKE_PREFIX_PATH=&lt;path_to_pfunit&gt;/build/installed \\\n        -DATMOSPHERIC_PHYSICS_ENABLE_TESTS=ON \\\n        -S./test/unit-test \\\n        -B./build\n$ cd build &amp;&amp; make\n$ ctest -V --output-on-failure\n</code></pre> <p>This should print something along the lines of</p> <pre><code>100% tests passed, 0 tests failed out of 1\n</code></pre> <p>or show an error if a test failed.</p>"},{"location":"atmospheric_physics/development_workflow/#adding-unit-tests","title":"Adding unit tests","text":"<p>For modules that are currently being built with CMake, are independent of any external library modules, and/or are dependent only on other modules that are already unit tested, it is recommended to add relevant tests that cover those new lines of code. If this doesn't apply to your module(s), skip this section.</p> <p>As unit test development is just as much an art form as source code development, we will defer a discussion on what constitutes as \"good tests\" to other sources such as MS.net, abseil, googletest, Martin Fowler, etc.  Just like with source code, philosophical/technical conventions will evolve with the code over time as well.</p>"},{"location":"atmospheric_physics/development_workflow/#adding-a-new-pfunit-test","title":"Adding a new pFUnit test","text":"<p>If you are adding a new file, add it to the list of files being built by the <code>test/unit-test/CMakeLists.txt</code>, and if it builds successfully, add a corresponding unit test.  The current workflow is to take your new file in <code>schemes/{path_to_file}/new_file.F90</code> and add a corresponding test file in <code>test/unit-test/tests/{path_to_file}/test_{new_file}.pf</code>.</p> <p>To add a test:</p> <ol> <li>Ensure the existing CMakeLists hierarchy covers the code you want to test (e.g. does the current directory have a CMakeList.txt file? If not, add one. Do you need other dependencies, and if so, are they CMake-ified and can be pulled in via a <code>find_package()</code> call? If you're unsure about the CMake requirements, please contact an AMP SE.</li> <li>Add the code being tested added to a library via <code>add_library(LIBNAME ...)</code> in the <code>test/unit-test/CMakeLists.txt</code> file.</li> <li>Create a new pFUnit test file to a corresponding directory matching the source file path into the unit-test directory.  For example, if your update added the file <code>schemes/utilities/new_file.F90</code>, create a new test file called <code>test/unit-test/tests/utilities/test_new_file.pf</code>.</li> <li>Add <code>add_pfunit_ctest(TESTNAME TEST_SOURCES test_new_file.pf LINK_LIBRARIES LIBNAME)</code> in the <code>CMakeLists.txt</code> file in the test directory corresponding to the new test file (ex. <code>test/unit-testing/tests/utilities/CMakeLists.txt</code> in this example).</li> <li>Add subroutines to the <code>test_new_file.pf</code> file of the form:</li> </ol> <pre><code>@test\nsubroutine test_added_element_equals_get_element()\n  use funit\n  use module_under_test_mod\n   ...\n   @assertEqual(expectedValue, atualValue)\n</code></pre> <p>Additional CMake integration details as well as the different assertion methods can be found in pFUnit's github documentation and the pFUnit demo repository as well.</p> <p>Currently, only certain <code>utilities</code> modules are being tested but this will expand to the rest of atmospheric_physics so check the files being built by the <code>test/unit-test/CMakeLists.txt</code> file regularly to see if you are modifying a file currently being tested.</p> <p>At a minimum, unit tests for ESCOMP source code should:</p> <ol> <li>Keep the setup code to the absolute minimum needed to effectively assert object/state data (ie, each line before calling <code>assert</code> statements should be modifying or preparing state data/objects to be modified exactly as a client or user would do).</li> <li>Only be 1 block/set of <code>assert</code> statements per test.  If there are multiple sets of <code>assert</code> statements with module API calls in between each set, that probably would constitute a new test with a different name.</li> <li>Have as explicit of names as possible.  There are going to be hundreds of names in each test report and having the ability for a reviewer/contributor to be able to look at a test and intuitively understand what said test is doing is paramount (this is obviously going to vary slightly based on preference but the goal is to have a test name be as intuitive as possible).</li> <li>Have clear and consise comments on what is being tested above each set of assert statements.</li> </ol> <p>You can find a unit testing example at the bottom of this page.</p>"},{"location":"atmospheric_physics/development_workflow/#6-creating-a-pull-request-pr","title":"6. Creating a Pull Request (PR)","text":"<p>1.  Go to the ESCOMP atmospheric_physics repo, and click on the \"Pull requests\" tab.</p> <p></p> <p>2.  There, you should see a \"New pull request\" button, which you should click.</p> <p></p> <p>3.  On the new \"Compare changes\" page, you should see a \"compare across forks\" link, which you should click.</p> <p></p> <p>4.  You should now see two new pull down boxes (to the right of an arrow).  Using those pull down boxes, select the \"development\" branch of the ESCOMP repo and select your fork (which should be <code>&lt;username&gt;/atmospheric_physics</code>):</p> <p></p> <p>Then select the branch which contains the new commits:</p> <p></p> <p>5. You should then see a list of all the different modifications.  If they generally look correct to you, then click the \"Create pull request\" button.</p> <p></p> <p>6. A new page should appear.  In the first text box add the title of your Pull request.  The second text box should contain additional fields that you should fill out to the best of your ability.</p> <p>7.  If you are contributing something into development that needs to go into the <code>main</code> branch quickly then please make it known in the PR description.  Also add the eventual tag name to the PR description.</p> <p>8.  Add any relevant labels to the Pull request, add yourself as the assignee, and add any reviewers you would like to have.  Otherwise the core SE team will add reviewers for you.</p> <p>9.  Fix any failing tests that show up on Github.</p> <p>10.  If you get any change requests during code review, then simply apply those changes in the same way you applied your original modifications.  Please note that once you <code>push</code> your changes then the PR will automatically be updated and the GitHub tests will be automatically run.</p> <p>11.  Update the <code>NamesNotInDictionary.txt</code> file using the instructions below.</p> <p>12.  Once all reviewers sign off on your modifications, then the PR can be merged.  Congratulations!  Your code is now in atmospheric_physics!</p> <ul> <li>If the PR is to <code>develop</code>, you should select \"Squash and Merge\"</li> <li>If the PR is to <code>main</code>, DO NOT squash and instead select \"Merge Commit\"</li> </ul>"},{"location":"atmospheric_physics/development_workflow/#updating-namesnotindictionarytxt-file","title":"Updating NamesNotInDictionary.txt file","text":"<p>1.  Clone the CCPP standard names dictionary.</p> <p><code>git clone https://github.com/ESCOMP/CCPPStandardNames.git</code></p> <p>2. Run the \"meta_stdname_check.py\" script to generate a new \"NamesNotInDictionary.txt\" file.</p> <p><code>CCPPStandardNames/tools/meta_stdname_check.py -m &lt;/path/to/atm_phys_repo&gt; -s CCPPStandardNames/standard_names.xml &gt; NamesNotInDictionary.txt</code></p> <p>Where <code>&lt;/path/to/atm_phys_repo&gt;</code> is a path to the head of your atmospheric_physics repo with all of the relevant changes.</p> <p>3.  Replace old names file with new one.</p> <p><code>cp NamesNotInDictionary.txt &lt;/path/to/atm_phys_repo&gt;/doc/NamesNotInDictionary.txt</code></p> <p>Finally, once the <code>NamesNotInDictionary.txt</code> file has been updated, then commit and push it to your branch/fork on Github following the instructions in the section above.</p>"},{"location":"atmospheric_physics/development_workflow/#removing-old-branches","title":"Removing old branches","text":"<p>Once your modifications have been merged into the official CAM repo, you may have no more use for the local fork branch created to develop those modifications.  In that case, you can remove the branch both from your local cloned repo and your atmospheric_physics fork:</p> <p>1.   First, make sure your local repo isn't checking out the old branch, by simply checking out a different branch:</p> <pre><code>    git checkout &lt;some_other_branch&gt;\n</code></pre> <p>2.   Then, remove branch from local repo:</p> <pre><code>    git branch -d &lt;branch_name&gt;\n</code></pre> <p>3.   Finally, remove branch from personal fork repo:</p> <pre><code>    git push --delete &lt;origin&gt; &lt;branch_name&gt;\n</code></pre> <p>You can also remove the branch via GitHub's user interface.</p>"},{"location":"atmospheric_physics/development_workflow/#unit-testing-example","title":"Unit testing example","text":"<p>Lets say you added a utility function in <code>physics_tendency_updaters.F90</code> to apply the pressure tendency of the atmosphere:</p> <pre><code>subroutine apply_tendency_of_air_pressure_run(nz, p_tend, pressure, dPdt_total,   &amp;\n    dt, errcode, errmsg)\n  ! Dummy arguments\n  integer,            intent(in)    :: nz              ! Num vertical  layers\n  real(kind_phys),    intent(in)    :: p_tend(:,:)     ! pressure tendency\n  real(kind_phys),    intent(inout) :: pressure(:,:)       ! air pressure\n  real(kind_phys),    intent(inout) :: dPdt_total(:,:) ! total temp. tendency\n  real(kind_phys),    intent(in)    :: dt              ! physics time step\n  integer,            intent(out)   :: errcode\n  character(len=512), intent(out)   :: errmsg\n\n  ! Local variable\n  integer :: klev\n\n  errcode = 0\n  errmsg = ''\n\n  do klev = 1, nz\n      pressure(:, klev) = pressure(:, klev) + (p_tend(:, klev) * dt)\n      dPdt_total(:, klev) = dPdt_total(:, klev) + p_tend(:, klev)\n  end do\n\nend subroutine apply_tendency_of_air_pressure_run\n</code></pre> <p>Then you would need to check that the file you've modified is being built by the tests.  You can check this in <code>test/unit-test/CMakeLists.txt</code> and see that we have:</p> <pre><code>set(UTILITIES_SRC\n    ../../schemes/utilities/state_converters.F90\n    ../../schemes/utilities/static_energy.F90\n    ../../schemes/utilities/physics_tendency_updaters.F90\n    include/ccpp_kinds.F90\n)\n</code></pre> <p>Since the file is being built, we don't have to add to this list.</p> <p>Next we look for <code>test/unit-test/tests/utilities/CMakeLists.txt</code> to see if there is a matching test file:</p> <pre><code>$ ls test/unit-test/tests/utilities/\nCMakeLists.txt\ntest_state_converters.pf\n$ cat test/unit-test/tests/utilities/CMakeLists.txt\nadd_pfunit_ctest(utilities_tests\n  TEST_SOURCES test_state_converters.pf\n  LINK_LIBRARIES utilities\n)\n</code></pre> <p>Because there is no matching file or test, we need to create it:</p> <pre><code>$ cat &gt; test/unit-test/tests/utilities/test_physics_tendency_updaters.pf &lt;&lt; EOF\n@test\nsubroutine test_pressure_tendency_update()\n  use funit\n  use physics_tendency_updaters\n\nend subroutine test_pressure_tendency_update\nEOF\n</code></pre> <p>And add the ability to build/run it from the test harness by updating <code>test/unit-test/tests/utilities/CMakeLists.txt</code>:</p> <pre><code>add_pfunit_ctest(utilities_tests\n  TEST_SOURCES test_state_converters.pf test_physics_tendency_updaters.pf\n  LINK_LIBRARIES utilities\n</code></pre> <p>where <code>test_physics_tendency_updaters.pf</code> has been added to the <code>TEST_SOURCES</code> list.</p> <p>Now, to actually test the function, we can try something like:</p> <pre><code>@test\nsubroutine test_pressure_tendency_update()\n  use funit\n  use ccpp_kinds, only: kind_phys\n  use physics_tendency_updaters\n\n  # Declare and setup test data with known results\n\n  integer, parameter :: ncol = 3            ! Num columns\n  integer, parameter :: nz = 3              ! Num vertical layers\n  integer, parameter :: errcode = 0\n  character(len=512), parameter :: errmsg = ''\n\n  real(kind_phys) :: p_tend(ncol, nz)    ! pressure tendency\n  real(kind_phys) :: pressure(ncol, nz)  ! air pressure\n  real(kind_phys) :: dPdt_total(nol, nz) ! total temp. tendency\n  real(kind_phys) :: dt                  ! physics time step\n\n  pressure = 1\n  p_tend = 1\n  dPdt_total = 0\n  dt = 1\n\n  call apply_tendency_of_air_pressure_run(nz, p_tend, pressure, &amp;\n                                          dPdt_total, dt,       &amp;\n                                          errcode, errmsg)\n\n  @assertEqual(2, pressure)\n  @assertEqual(1, dPdt_total)\n  @assertEqual(0, errcode)\n  @assertEqual('', errmsg)\nend subroutine test_pressure_tendency_update\n</code></pre> <p>The values should be scientifically relevant to test a valid physics case or be set up to test edge cases that the subroutine must support.</p> <p>Notice that we are only testing <code>intent(out)</code> and <code>intent(inout)</code> as these are the only values that can change.</p> <p>Assuming you have built the test framework according to the instructions, you can now run:</p> <pre><code>$ cmake \\\n  -DCMAKE_PREFIX_PATH=&lt;PATH_TO_PFUNIT&gt;/build/installed \\\n  -DATMOSPHERIC_PHYSICS_ENABLE_CODE_COVERAGE=ON \\\n  -B./build \\\n  -S./test/unit-test\n$ cd build\n$ make\n$ ctest -V --output-on-failure\n</code></pre> <p>After which you should see output similar to:</p> <pre><code>1:  Start: &lt;test_state_converters_suite.test_temp_to_potential_temp&gt;\n1: .   end: &lt;test_state_converters_suite.test_temp_to_potential_temp&gt;\n1:\n1: Time:         0.000 seconds\n1:\n1:  OK\n1:  (1 test)\n1:\n2:  Start: &lt;test_physics_tendency_updaters_suite.test_pressure_tendency_update&gt;\n2: .   end: &lt;test_physics_tendency_updaters_suite.test_pressure_tendency_update&gt;\n2:\n2: Time:         0.000 seconds\n2:\n2:  OK\n2:  (1 test)\n2/2 Test #1: utilities_tests ..................   Passed    0.00 sec\n\n100% tests passed, 0 tests failed out of 1\n</code></pre> <p>If 100% of the tests pass, you're good to go!</p>"},{"location":"atmospheric_physics/directory-structure/","title":"atmospheric_physics directory structure","text":"<p>This page lists out the directory structure for the atmospheric_physics repo, and what the general purpose of each directory and subdirectory is.</p>"},{"location":"atmospheric_physics/directory-structure/#top-level-directories","title":"Top-level directories","text":"<p>These directories represent code and tools that are contained within the atmospheric_physics repository.</p>"},{"location":"atmospheric_physics/directory-structure/#doc","title":"doc/","text":"<p>Contains files used to document the current state of the atmospheric_physics repository, such as a <code>ChangeLog</code> and the <code>NamesNotInDictionary.txt</code> file which lists all standard names that are currently not in the official CCPP Standard Names repo. More on the NamesNotInDictionary.txt file here.</p>"},{"location":"atmospheric_physics/directory-structure/#schemes","title":"schemes/","text":"<p>Contains subdirectories for all of the CCPP-ized physics schemes, with the subdirectories containing the core physics scheme source code, the associated CCPP metadata files, namelist XML files, and any relevant dependency files.</p> <p>Note that there is a special <code>to_be_ccppized</code> subdirectory which contains source code that is needed by certain CCPP physics schemes, but which is not yet fully CCPP compliant (e.g. may have code that is host-model-specific).</p>"},{"location":"atmospheric_physics/directory-structure/#suites","title":"suites/","text":"<p>Contains CCPP Suite Definition Files (SDFs) for official scientific and production configurations of the CAM-SIMA host model.</p>"},{"location":"atmospheric_physics/directory-structure/#test","title":"test/","text":"<p>Contains code and tools used to run tests on the CCPP-ized physics schemes.</p> <p>Subdirectories:</p> <ul> <li>cmake   - Contains cmake files needed to configure and build  unit tests.</li> <li>docker  - Contains dockerfiles needed to configure, build, and run unit tests.</li> <li>include - Contains utility source code needed to build and run unit tests.</li> <li>musica  - Contains test code for the CCPP-ized Multi-Scale Infrastructure for Chemistry Modeling (MUSICA) components.</li> <li>test_suites - Contains test SDFs for use in CAM-SIMA snapshot regression testing.</li> </ul>"},{"location":"conversion/back-to-cam/","title":"9 - Bring back into CAM","text":""},{"location":"conversion/back-to-cam/#code-modifications","title":"Code modifications","text":"<p>Bring the CCPP version back into a new CAM clone or branch</p> <ul> <li>Make a new clone or branch of CAM6 (personal preference)</li> <li>Remove the non-CCPP version from your CAM source directory</li> <li>Make a new directory in the atmosperhic_physics submodule of CAM (make sure the directory name is the one you used in step one of the conversion to CCPP):</li> </ul> <pre><code>mkdir src/atmos_phys/schemes/&lt;parameterization&gt;\n</code></pre> <ul> <li>Copy your new CCPP version files from CAM-SIMA into this new directory</li> <li>Update the routine names to match the CCPP-ized subroutine names where the subroutines are called</li> <li>Update the calling lists if they were changed when the CCPP-ized subroutines were made</li> <li>If the CCPP-ized module is in a new subdirectory, you will need to add it to <code>bld/configure</code>:</li> </ul> <pre><code>print $fh \"$camsrcdir/src/atmos_phys/schemes/&lt;parameterization&gt;\\n\";\n</code></pre> <p>Handling readnl and diagnostics in CAM</p> <p>The original <code>&lt;parameterization&gt;_readnl</code> subroutine (if there was one) must still be called in runtime_opts.F90 and all addfld/outfld calls must be preserved. If your new CCPP interfaces are called directly by physpkg, this may mean that you need to create a <code>&lt;parameterization&gt;_cam.F90</code> module that contains <code>&lt;parameterization&gt;_readnl</code>. </p>"},{"location":"conversion/back-to-cam/#testing","title":"Testing","text":"<ul> <li>To quickly test that your code is working during development, you can create two new model cases with a compset that involves your physics scheme, and the following XML changes:</li> </ul> <pre><code>./xmlchange --force ROF_NCPL=\\$ATM_NCPL\n./xmlchange DOUT_S=FALSE,STOP_OPTION=nsteps,STOP_N=9,DEBUG=TRUE\n</code></pre> <p>Note</p> <p>The first case will be CAM without your changes, and the second will be CAM with your new physics scheme code changes. Both simulations should produce a <code>&lt;case_name&gt;.cam.rh0.XXX</code> file, which you can compare by using the cprnc tool, which can be found (and used) on derecho below. Your new physics code is working correctly if the printed output from cprnc states that there are no differences in the files.</p> <pre><code>/glade/campaign/cesm/cesmdata/cprnc/cprnc\ncprnc &lt;file1&gt; &lt;file2&gt;\n</code></pre> <ul> <li>Optional step: if want to have additional testing... Once you believe it is working, make a snapshot to run CAM with this modified clone.<ul> <li>Use the cprnc tool to compare the resulting CAM6 \u201cafter\u201d snapshot file with your original CAM6 \u201cafter\u201d snapshot file (from before the port). If they differ and you changed the internal calculations during your port, you will need to determine if these changes are expected and correct.  <ul> <li>If they are different (and the changes are correct), then you will need to repeat the steps listed in the Run CAM-SIMA section with the newly generated snapshot files from the modified CAM clone.</li> </ul> </li> </ul> </li> </ul> <p>Proceed to Step 10 - Final Steps</p>"},{"location":"conversion/check-metadata/","title":"7 - Check metadata","text":"<ul> <li>Create and configure a short test case in CAM-SIMA that exercises your new scheme. You may find it easiest to use the FPHYStest compset (using the null dycore). For more on setting up a case, see Create a case</li> </ul> <pre><code>./create_newcase --case &lt;casedir&gt; --compset FPHYStest --res ne3pg3_ne3pg3_mg37 --compiler &lt;compiler&gt; --run-unsupported\ncd &lt;casedir&gt;\n./xmlchange CAM_CONFIG_OPTS=\"--dyn none --physics-suites &lt;parameterization&gt;\"\n./xmlchange STOP_OPTION=\"nsteps\"\n./xmlchange STOP_N=&lt;some # of steps less than your snapshot file contains&gt;\n./xmlchange DOUT_S=False\n</code></pre> <ul> <li>Run <code>./preview_namelists</code> to see if the framework will generate the caps. A few possible outcomes:<ul> <li>There are no errors and you are somehow a perfect person. Move on to the next step and ultimately run the model</li> <li>You get an error<ul> <li>Determine what the course of action should be based on the table below. Once you think you have addressed the issue, rerun <code>./preview_namelists</code> and repeat!</li> </ul> </li> </ul> </li> </ul> Error Situation Action <code>Input argument for &lt;scheme&gt;_&lt;phase&gt;, &lt;standard_name&gt;, not found</code> Standard name incorrect when compared against the spreadsheet Correct standard name Variable traced back to \"use\" statement in CAM Follow procedure 1 below Variable is a constituent (can be traced back to the <code>state%q</code> array in CAM) Add <code>advected = true</code> to the variable's metadata in your parameterization Variable can be traced back to a calculation in the CAM interface code Make an interstitial None of the above criteria are met Follow procedure 2 to add the variable to the registry <code>parse_source.ParseSyntaxError: Unsupported unit conversion, '&lt;unit1&gt;' to '&lt;unit2&gt;' for '&lt;standard_name&gt;'</code> Units do not match and there is not automatic unit converter for the conversion Follow procedure 3 <code>parse_source.CCPPError: Invalid 'standard_name' property value</code> Standard name is not parsing correctly Look for a missing \"_\" or a typo in the standard name <code>CCPPError: Could not find dimension, &lt;dimension1&gt;:&lt;dimension2&gt;, in &lt;variable&gt;</code> Dimension is either invalid or not implemented in CAM Confirm that the dimension is valid and that you selected the correct one (e.g. <code>vertical_layer_dimension</code> vs <code>vertical_interface_dimension</code>. If it's valid and still missing, consult with the other CAM SEs <code>parse_source.ParseInternalError: Duplicate Group variable &lt;variable&gt;</code> You have multiple variables (with different standard names) that have the same local name Change the local name of one (or more) of the variables in your Fortran and metadata Some other misc error You've run into either a bug or just a weird scenario If the error message is unhelpful, ask Courtney <p>Once you have validated your metadata, proceed to 8 - Run CAM-SIMA</p>"},{"location":"conversion/check-metadata/#procedure-1","title":"Procedure 1","text":"<p>If the CAM variable can be traced back to a use statement, you may have to create or amend a SIMA-side metadata file.</p> <ul> <li>Try to find the equivalent module and the \"used\" variable within it in CAM-SIMA<ul> <li>If you find it the module:<ul> <li>It already has a metadata file, move the variable in the Fortran to be with the other variables that have metadata. Then, add your variable to the appropriate place in the metadata file.</li> <li>It doesn't have a metadata file, create one and add your variable. You'll also have to add the \"html\" tags and potentially rearrange module-level variables so the only variable(s) under the tags are the ones you're providing metadata for.</li> <li>Then add the path to the metadata file to the <code>metadata_file</code> section of <code>$CAM-SIMA/src/data/registry.xml</code></li> </ul> </li> <li>If you can't find the module, consult with the other CAM SEs</li> </ul> </li> </ul>"},{"location":"conversion/check-metadata/#procedure-2","title":"Procedure 2","text":"<p>If the variable in question cannot be tracked back to a \u201cuse\u201d statement or a calculated value in the CAM interface code, it likely needs to be provided by the host model. To enable this, you\u2019ll have to add the variable to the registry (<code>$CAM-SIMA/src/data/registry.xml</code>). Here is the structure of how that will look:</p> <pre><code>&lt;variable local_name=\"phis\"         \n              standard_name=\"surface_geopotential\"\n              units=\"m2 s-2\" type=\"real\" kind=\"kind_phys\"\n              allocatable=\"allocatable\"&gt;\n      &lt;dimensions&gt;horizontal_dimension&lt;/dimensions&gt;\n      &lt;ic_file_input_names&gt;phis state_phis&lt;/ic_file_input_names&gt;\n&lt;/variable&gt;\n\n</code></pre> <ul> <li>If the variable you are adding is a state or ptend variable, be sure to also add the variable standard name to the relevant ddt in the registry.</li> <li><code>dimensions</code> is a space-separated list (in order) of the standard names of the dimensions for the variable</li> <li><code>ic_file_input_names</code> is a space-separated list of possible names on the snapshot/inputdata file</li> </ul> <p>Note</p> <p>Variables in the registry are read in from the initial data file by default.</p> <p>Should I add a variable to the registry or rely on CCPP to manage the variables being passed between schemes?</p> <p>While declaring a variable in the scheme metadata files allows CCPP to pass this variable from a scheme and to another scheme without having to define it in the registry, it is important to note that variables not declared in the registry are not preserved between timesteps (i.e., the timestep initialization phase will reallocate these variables). Thus variables that should be preserved as part of model \"state\" or (formerly) physics buffer variables with time dimensions (e.g., total energy at end of previous physics timestep) should be included as part of the registry.</p> <p>There are two options for registry variables:</p> <ol> <li>Variable read in from the initial data file: no action required</li> <li>Variable not read in from the initial data file, and instead initialized during CAM-SIMA initialization. You will need to add code to do this:<ul> <li>Determine the best place to initialize this variable (has to occur at some point during initialization - see CAM-SIMA run</li> <li>In the location you have chosen, add the use statements below to import the registry variable from the auto-generated fortran AND the mark_as_initialized routine</li> <li>After adding the code to initialize the variable, add the <code>mark_as_initialized</code> call below to indicate that that variable should NOT be read in from the file.</li> </ul> </li> </ol> <pre><code>use physics_types, only &lt;var_local_name&gt;\nuse phys_vars_init_check, only: mark_as_initialized\n</code></pre> <pre><code>&lt;var_local_name&gt; = &lt;something&gt;\ncall mark_as_initialized('&lt;var_standard_name&gt;')\n</code></pre>"},{"location":"conversion/check-metadata/#procedure-3","title":"Procedure 3","text":"<p>The units you are using for a variable in your converted scheme has a different unit than the host model (or possibly different from elsewhere in your suite). </p> <ul> <li>Do a grep in $CAM-SIMA/src for the standard name to see what the discrepancy is.</li> <li>Double-check that the units for your scheme match the units in the spreadsheet</li> <li>If it seems like the automatic unit converter should be able to handle the unit conversion, talk to Courtney</li> <li>If it\u2019s more of a one-off conversion, two options remain:<ol> <li>Write an interstitial for the unit conversion</li> <li>Include the conversion in the scheme code (you will also need to update the CAM interface to make sure it\u2019s passing in the same units as the CAM-SIMA host has)</li> </ol> </li> </ul>"},{"location":"conversion/conversion-background/","title":"0 - Background &amp; Prep work","text":""},{"location":"conversion/conversion-background/#background","title":"Background","text":""},{"location":"conversion/conversion-background/#running-jobs-in-cam-and-cam-sima","title":"Running jobs in CAM and CAM-SIMA","text":"<p>See this section for how to run CAM-SIMA and CAM.</p> <p>Depending on which machine you are on, you may prefer to run the ./case.build command on a compute node instead of the login node due to user resource utilization limits on the login nodes.</p>"},{"location":"conversion/conversion-background/#prep-work","title":"Prep Work","text":""},{"location":"conversion/conversion-background/#conversion-spreadsheet","title":"Conversion Spreadsheet","text":"<p>Put the parameterization that you are going to convert into the conversion spreadsheet.</p>"},{"location":"conversion/conversion-background/#create-github-issues","title":"Create Github Issues","text":"<ol> <li>Create a Github Issue in the ESCOMP/CAM repo that states which physics parameterization you are planning to convert to the CCPP framework.  <ul> <li>be sure to add the <code>ccpp-conversion</code> label</li> </ul> </li> <li>Create another issue in the ESCOMP/atmospheric physics repo describing the same physics parameterization that you are now planning to add to the collection of NCAR CCPP physics suites.  Doing this allows the software engineers to keep track of which physics routines are being worked on, and which still need to be assigned.  The goal of converting the physics parameterization is to ultimately have the CCPP-ized physics package reside in ESCOMP atmospheric physics and be removed from ESCOMP/CAM.</li> </ol>"},{"location":"conversion/conversion-background/#setting-up-your-sandbox","title":"Setting up your sandbox","text":"<p>Make sure you have github forks for both ESCOMP/CAM-SIMA and ESCOMP/atmospheric_physics.  If needed see Working with git and GitHub</p> <p>To begin, fork ESCOMP/CAM-SIMA: </p> <p>And select the <code>Create new fork</code> option.  This will bring you to the \"Create new fork\" screen: </p> <p>Uncheck the \"Copy the <code>main</code> branch only\" option</p> <p>Failure to uncheck this will prevent you from pulling in updates from the <code>development</code> branch easily.</p>"},{"location":"conversion/conversion-background/#set-up-local-clones-and-branches","title":"Set up local clones and branches","text":"<ul> <li>On the machine and in the directory in which you would like to develop, clone CAM-SIMA (the CCPP-ized version of CAM) with your fork as the origin:</li> </ul> <pre><code>git clone -o &lt;your_github_userid&gt; https://github.com/&lt;your_github_userid&gt;/CAM-SIMA CAM-SIMA\n</code></pre> <ul> <li>Navigate into the directory you just created:</li> </ul> <pre><code>cd CAM-SIMA\n</code></pre> <ul> <li>Add the <code>ESCOMP</code> remote so you can keep your fork up to date:</li> </ul> <pre><code>git remote add ESCOMP https://github.com/ESCOMP/CAM-SIMA\n</code></pre> <ul> <li>Fetch the upstream ESCOMP tags and branches from GitHub:</li> </ul> <pre><code>git fetch --tags ESCOMP\n</code></pre> <ul> <li>Create and checkout a new branch off of the <code>development</code> branch of the ESCOMP remote:</li> </ul> <pre><code>git branch &lt;branch_name&gt; ESCOMP/development\ngit checkout &lt;branch_name&gt;\n</code></pre> <ul> <li>Set up the upstream (on GitHub) version of your branch:</li> </ul> <pre><code>git push -u &lt;your_github_userid&gt; &lt;branch_name&gt;\n</code></pre> <ul> <li>Populate your externals:</li> </ul> <pre><code>bin/git-fleximod update\n</code></pre> <ul> <li>Make a new directory for your parameterization within the atmospheric_physics submodule directory</li> </ul> <pre><code>mkdir src/physics/ncar_ccpp/schemes/&lt;parameterization_name&gt;\n</code></pre> <ul> <li>Navigate into the atmospheric_physics submodule directory</li> </ul> <pre><code>cd src/physics/ncar_ccpp\n</code></pre> <ul> <li>Add your fork of atmospheric_physics as a remote</li> </ul> <pre><code>git remote add &lt;your_github_userid&gt; https://github.com/&lt;your_github_userid&gt;/atmospheric_physics\n</code></pre> <ul> <li>Fetch the upstream branches and tags</li> </ul> <pre><code>git fetch &lt;your_github_userid&gt;\n</code></pre> <ul> <li>Create, checkout, and push a new branch upstream</li> </ul> <pre><code>git checkout -b &lt;physics_branch_name&gt;\ngit push -u &lt;your_github_userid&gt; &lt;physics_branch_name&gt;\n</code></pre> <p>Multiple repositories!</p> <p>As you make changes and want to commit them to your github repos, you\u2019ll be managing two separate repos.  When you issue git commands, be aware of where you are in your code tree.</p> <ul> <li>If you want to see changes in CAM-SIMA, you can issue a \u201cgit status\u201d in the main CAM-SIMA directory.</li> <li>If you want to see changes in the atmospheric_physics repo, make sure you are in src/physics/ncar_ccpp before you issue the \u201cgit status\u201d command.</li> <li>All other git commands will be relative to your current working directory as well.</li> </ul> <p>Congratulations! You've set up your sandbox! Proceed to 1 - Convert the \"portable\" layer</p>"},{"location":"conversion/convert-portable-layer/","title":"1 - Convert the \"portable\" layer","text":""},{"location":"conversion/convert-portable-layer/#move-the-portable-layer-to-atmospheric_physics","title":"Move the portable layer to atmospheric_physics","text":"<p>The portable parameterization layer is the module that contains the core physics code that is called by the CAM interface.</p> <p>The portable module will most likely live in <code>$CAM/src/physics/cam</code> or <code>$CAM/src/physics/cam7</code></p> <p>The driver code in each physics directory is <code>physpkg.F90</code>, which typically calls the CAM interface to the portable layer (often called <code>&lt;parameterization&gt;_cam.F90</code>), but also sometimes calls portable layer directly. Once you locate the core code that you will be converting, copy it into the new directory you created in the atmospheric_physics submodule directory:</p> <pre><code>cp $CAM/src/physics/&lt;physics_subdir&gt;/&lt;file&gt;.F90 $CAM-SIMA/src/physics/ncar_ccpp/schemes/&lt;parameterization_name&gt;\n</code></pre>"},{"location":"conversion/convert-portable-layer/#optional-pre-split-the-module","title":"Optional: pre-split the module","text":"<p>Many CAM schemes have more than one \"run\" or \"tend\" method contained within them.  To split them into separate files and test them, do the following:</p> <ul> <li>In the atmospheric physics directory (<code>ncar_ccpp/schemes/&lt;parameterization_name&gt;</code>), create a separate module for each piece which has a \"run\" or \"tend\" method.<ul> <li>An easy way to see what routines need to be separated out, is to look at the \"use\" statement(s) in <code>physpkg.F90</code> for your parametrization's module.  If more than one routine is listed, you most likely will need to separate these out.</li> </ul> </li> <li>If there is shared, module-level data or shared subroutines which are called internally, put these all in a _common.F90 module."},{"location":"conversion/convert-portable-layer/#1a-change-routine-names","title":"1a - Change routine names","text":"<p>Convert the original routines (except readnl - we'll get to that later!) in the file(s) you copied over to $CAM-SIMA/src/physics/ncar_ccpp to one or more of the following 5 subroutines:</p> <p><code>&lt;parameterization&gt;</code> should be the full name of your module</p> <p>For example, if you are converting the <code>tj2016</code> <code>precip_tend</code> function, then <code>&lt;parameterization&gt;</code> would be <code>tj2016_precip_tend</code>.</p> <ul> <li>&lt;parameterization&gt;_register<ul> <li>Add all code that is run only during the first timestep (nstep=0) BEFORE the physics grid has been set up.</li> </ul> <p>Grid is not set up!</p> <p>Only scalar variables can be passed in at this time, as the grid is not set up (no horizontal or vertical dimensions are available)</p> <ul> <li>If your scheme has runtime constituents, this is place to add those (see Runtime Constituent Usage)</li> </ul> </li> <li>&lt;parameterization&gt;_init<ul> <li>Add all code that is run only during the first timestep (nstep=0) AFTER the physics grid has been set up.</li> </ul> </li> <li>&lt;parameterization&gt;_timestep_init<ul> <li>Add all pre-processing code needed by the scheme at the start of each timestep. This may contain code from the CAM interface (<code>physpkg.F90</code>) routine which prepares data for the run routine at each timestep</li> </ul> </li> <li>&lt;parameterization&gt;_run<ul> <li>This is the workhorse routine which is run at each timestep. The bulk of your ported code will likely be here.</li> <li>Often, the workhorse routine in CAM is called <code>&lt;parameterization&gt;_tend</code></li> </ul> </li> <li>&lt;parameterization&gt;_timestep_final<ul> <li>Add all post-processing code needed by the scheme at the end of each timestep. This may contain code from the CAM interface routine (in <code>physpkg.F90</code>) which manipulates data after the run routine at each timestep</li> </ul> </li> <li>&lt;parameterization&gt;_final<ul> <li>Most current CAM routines do not have code in this category. This code is run once at the very end of the CAM model execution.</li> </ul> </li> </ul> <p>Note</p> <p>You may not need all of the routines listed, nor do you need to supply them if they are not needed; however, all subroutine input/output (dummy) arguments need to have an \"intent\" label.</p>"},{"location":"conversion/convert-portable-layer/#1b-add-required-htmlinclude-lines","title":"1b - Add required <code>\\htmlinclude</code> lines","text":"<p>Add two lines before each of the up to 5 phases of subroutines (skip <code>readnl</code>)</p> <pre><code>!&gt; \\section arg_table_&lt;parameterization&gt;_&lt;phase&gt; Argument Table\n!! \\htmlinclude &lt;parameterization&gt;_&lt;phase&gt;.html\n</code></pre>"},{"location":"conversion/convert-portable-layer/#1c-clean-up-dummy-argument-dimensions","title":"1c - Clean up dummy argument dimensions","text":"<p>Make sure no input/output variables have named dimensions in their declaration inside the routines.  </p> <ol> <li>Replace named dimensions with \u201c:\u201d<ul> <li>for example: <code>real(r8), intent(in) :: zm(pcols, pver)</code> will become <code>real(r8), intent(in) :: zm(:,:)</code></li> </ul> </li> <li>If a named dimension is no longer used, it may be removed from the calling list (i.e. pcols, etc)</li> <li>On the CAM interface side, any variables dimensioned by <code>pcols</code> in CAM will need to be subsetted to <code>1:ncol</code> in the call to the CCPP-ized routine so that only the active columns are passed</li> <li>All <code>intent(out)</code> variables which are dimensioned <code>pcols</code> should be initialized to zero right before being called in the main CAM physics calling routine to prevent extraneous values from existing in a pcols-dimensioned array.<ul> <li>Put <code>!REMOVECAM/!REMOVECAM_END</code> labels around these initializations as any which remain after CAM is retired no longer need this precautionary step.</li> </ul> </li> <li>Repeat #1-4 with any routines which are called internally</li> <li>Search through the code and make sure that all locations which call these updated routines have been modified correctly<ul> <li>Use the subsetted 1:ncol arrays when calling the updated routine </li> <li>Initialize all intent(out) arrays to zero before making the call</li> </ul> </li> </ol> <p>Note</p> <p>When calling CCPPized subroutines from CAM, only the active columns (<code>1:ncol</code>) should be passed in. Because CAM distinguishes between <code>ncols</code> and <code>pcols</code>, output variables sized <code>pcols</code> must be initialized to zero, because the CCPPized subroutines will only be able to modify the active columns <code>1:ncol</code>.</p>"},{"location":"conversion/convert-portable-layer/#1d-use-kind_phys-instead-of-r8","title":"1d - Use kind_phys instead of r8","text":"<ol> <li>Remove <code>use shr_kind_mod, only: r8=&gt; shr_kind_r8</code></li> <li>Replace with <code>use ccpp_kinds, only: kind_phys</code></li> <li>Do a find and replace for <code>r8</code> with <code>kind_phys</code> in the module (and any dependencies)</li> </ol>"},{"location":"conversion/convert-portable-layer/#1e-remove-use-statements","title":"1e - Remove use statements","text":"<p>Remove all \u201cuse\u201d statements and have the data appear in the calling list (the input and output variables to the routine).  The only exception to this rule is for use statements to routines contained within the parameterization package or dependencies.</p> <ul> <li>If a use statement is bringing in a variable from another module (e.g. something from <code>physconst</code>), add the variable to the calling list of the subroutine(s) that use it (and remove the use statement)</li> <li> <p>If a use statement is bringing in an external routine (not part of the parameterization package), you have a few options (consult with the other CAM SEs on how to proceed):</p> <ol> <li>If the routine already exists in the core CAM-SIMA code tree (not in <code>ncar_ccpp</code>), ask another CAM SE about how and where to call the routine within the CAM-SIMA run loop and set a variable to be passed into the physics (variable will need to be added to the registry)</li> <li>CCPP-ize the external routine and/or module and add it to the suite definition file before or after the parameterization</li> <li> <p>Postpone CCPP-zing the external routine and move the module to the <code>to_be_ccppized</code> directory in <code>atmospheric_physics</code> so it can be used as a dependency (we'll revisit this in create metadata)</p> <p>'init' routine in to_be_ccppized module</p> <p>If you are putting off ccpp-ization of a dependent module and that module has an init routine, you may have to add a call to that routine in the init phase of the <code>to_be_ccppized_temporary</code> scheme (<code>$atmospheric_physics/to_be_ccppized/to_be_ccppized_temporary.F90</code>) and ensure <code>to_be_ccppized_temporary</code> is included in your SDF</p> </li> </ol> </li> <li> <p>Comment out <code>outfld</code>, <code>addfld</code> use statements for now</p> <ul> <li>Also comment out the <code>addfld</code> and <code>outfld</code> calls within the module(s)</li> </ul> </li> </ul>"},{"location":"conversion/convert-portable-layer/#1f-add-error-variables","title":"1f - Add error variables","text":"<p>Add <code>errmsg, errflg</code> to the end of your calling list.  Set <code>errflg</code> to non-zero if an error is encountered in your routine and set <code>errmsg</code> with an appropriate text indicating the error. </p> <p>The declarations for these variables are:</p> <pre><code>   character(len=512), intent(out) :: errmsg\n   integer,            intent(out) :: errflg\n</code></pre> <p>At the top of your routine initialize the variables as follows:</p> <pre><code> errmsg = \u2018 \u2018\n errflg = 0\n</code></pre>"},{"location":"conversion/convert-portable-layer/#1g-replace-state-and-ptend-variables-in-calling-list","title":"1g - Replace state and ptend variables in calling list","text":"<p><code>state</code> and <code>ptend</code> variables will not be passed in as full objects, but instead as the individual state and ptend fields that are used in the routine.</p> <p>If <code>state</code> appears in the calling list:</p> <ol> <li>Search the routine for \"state%\" and, for each of the distinct variables found (<code>state%&lt;var&gt;</code>), add the variable (<code>&lt;var&gt;</code>) to the calling list</li> <li>Replace all calls to <code>state%&lt;var&gt;</code> with <code>&lt;var&gt;</code></li> <li>Remove <code>state</code> from the calling list</li> </ol> <p>If <code>ptend</code> appers in the calling list:</p> <ol> <li>Search the routine for \"ptend%\" and, for each of the distinct variables found (<code>ptend%&lt;var&gt;</code>), add the variable to the calling list<ul> <li>the variable name is up to you, some suggestions:<ol> <li><code>&lt;var&gt;_tend</code></li> <li><code>d&lt;var&gt;dt</code></li> </ol> </li> </ul> </li> <li>Replace all calls to <code>state%&lt;var&gt;</code> with the new name</li> <li>Remove <code>ptend</code> from the calling list</li> </ol>"},{"location":"conversion/convert-portable-layer/#1h-remove-pbuf-variables","title":"1h - Remove pbuf variables","text":"<p>pbuf variables will not be in CCPP code. Instead, pass required individual variables as <code>intent(in)</code>, <code>intent(out)</code> or <code>intent(inout)</code> depending on whether they are being used or set in the interstitial.</p> <p>For example, if the following line of code exists in a routine:</p> <pre><code>call pbuf_get_field(pbuf, taubljx_idx, taubljx)\n</code></pre> <p>You will want to search around in the routine (and routines that it calls) to determine if <code>taubljx</code> is read from, written to, or both:</p> <ol> <li>If the variable is read from only (e.g. is only on the right-hand side of equations), the variable will be <code>intent(in)</code></li> <li>If the variable is written to only (e.g. is only on the left-hand side of equations), the variable will be <code>intent(out)</code></li> <li>If the variable is both read from and written to (e.g. it appears on both sides of equations), the variable will be <code>intent(inout)</code></li> </ol> <p>In this example, <code>taubljx</code> is <code>intent(out)</code>, so we'd remove the <code>pbuf_get_field</code> call and add <code>taubljx</code> to the calling list as an ouput variable.</p>"},{"location":"conversion/convert-portable-layer/#1i-mark-variables-as-initialized","title":"1i - Mark variables as initialized","text":"<ul> <li>If you add new variables that do not need to be read in from a file but come directly from the host model/registry and are uninitialized by CAM-SIMA, use the <code>mark_as_initialized</code> subroutine in the <code>&lt;parameterization&gt;_init</code> phase.</li> <li>Also, if you are setting a (non-namelist) public module level variable(a variable above the contains statement) in CAM-SIMA that will be used by a physics scheme, then also set the mark_as_initialized for that variable (also in the <code>&lt;parameterization&gt;_init</code> phase)</li> </ul> <pre><code>use phys_vars_init_check, only: mark_as_initialized\n</code></pre> <pre><code>call mark_as_initialized('&lt;standard name&gt;')\n</code></pre>"},{"location":"conversion/convert-portable-layer/#1j-initial-standard-name-check","title":"1j - Initial standard name check","text":"<p>Do a preliminary look at the variables on the calling lists and make sure that CCPP standard names and units exist for all of them, by checking for them in CAM Standard Names Spreadsheet.</p> <ul> <li>If variables are not filled out in the list, highlight the entire line with yellow.  </li> <li>If they don't exist at all in the spreadsheet, enter them into the bottom of the sheet and highlight them with yellow.  Note that physconst and diagnostic-only variables may not reside in the spreadsheet.</li> <li>Let Jesse, Courtney or Cheryl know if you've encountered missing CCPP standardnames and/or units and added them to the list, so they can be discussed at an upcoming meeting.  </li> <li>If you create your own name, add <code>_TBD</code> to the end of the name to signify that it has not been discussed yet.</li> </ul> <p>Note</p> <p>This process can normally take 2-4 weeks, so a preliminary look is advisable.</p>"},{"location":"conversion/convert-portable-layer/#1k-optional-make-a-cam-tag","title":"1k - OPTIONAL: Make a CAM tag","text":"<p>Make ESCOMP/atmospheric_physics and ESCOMP/CAM tags if substantial changes have been made up to this point.  This is also a good step to take if there is potential for others to be making modifications to the same physics module.  This will allow them to make changes which can be merged via git commands. More on bringing your changes back to CAM here.</p> <ul> <li>Do at the very least a sanity compilation and run using the ESCOMP/CAM code base <ul> <li>Delete the original module from src/physics/cam </li> <li>Use  your pulled apart modules in <code>atmos_phys/schemes/&lt;parameterization_name&gt;</code>.</li> <li>In bld/configure in the ESCOMP/CAM source code, find the section \"Add the CCPP'ized subdirectories\".  Add following line:</li> </ul> </li> </ul> <pre><code>print $fh \"$camsrcdir/src/atmos_phys/schemes/&lt;parameterization_name&gt;\\n\";\n</code></pre> <ul> <li>Modify code as needed until this modified code compiles and runs properly.</li> <li>If you want to benchmark your development to this point, you will need to open PRs to both ESCOMP/atmospheric_physics and ESCOMP/CAM.</li> </ul> <p>Proceed to 2 - Create metadata</p>"},{"location":"conversion/create-metadata/","title":"2 - Create metadata","text":""},{"location":"conversion/create-metadata/#create-template","title":"Create template","text":"<p>To create a template metadata file based on the parameterization, run the following command in the directory with the routine you are converting (.F90): <pre><code>python $CAM-SIMA/ccpp_framework/scripts/ccpp_fortran_to_metadata.py &lt;parameterization&gt;.F90 \n</code></pre> <p>If you get errors:</p> <ol> <li>Confirm you included the argtable lines above each routine</li> <li>If you see a message \"Missing local variables\" and the variable is there, it may be missing its intent attribute</li> <li>Hopefully other errors will be easy to address; consult other CAM SEs if there's any remaining confusion/errors</li> </ol> <p>Completion of <code>ccpp_fortran_to_metadata.py</code> will result in the creation of <code>&lt;parameterization&gt;.meta</code></p>"},{"location":"conversion/create-metadata/#complete-metadata","title":"Complete metadata","text":"<p>Replace all <code>enter_*</code> sections with appropriate information (standard_name, units, dimensions, long_name). Special handling for error variables, constituents, and dependencies can be found below.</p> <p>Named dimension in metadata template</p> <p>If you have a dimension in the metadata field which is NOT of the form <code>enter_standard_name_X:enter_standard_name_Y</code> but is rather a single dimension without a :, this means that you have a named dimension in your converted routine and you should remove the name and replace it with \":\"</p> <ul> <li>standard_name: the mapping between CAM variables and standard_names can be found in this spreadsheet. All official standard names (approved by all stakeholders) can be found in the CCPPStandardNames repo. Note that this does not yet contain all of the spreadsheet names.<ul> <li>You may have to trace the variable back through the CAM code to find the <code>Snapshot or Local name</code> to look for</li> <li>Officially accepted standard names can be found in this repository, but the CAM Standard Names Spreadsheet should include all of the CAM variables.</li> <li>If a standard name is not found:<ul> <li>CCPP names are trying to adhere to CF names, so you may find names on the CF web page: https://cfconventions.org/Data/cf-standard-names/76/build/cf-standard-name-table.html</li> <li>If you need to create your own standard name, the current proposal for creating standard names can be found here: https://github.com/ESCOMP/CCPPStandardNames/blob/main/StandardNamesRules.rst </li> <li>May need to consult with WRF / MPAS scientists and other SIMA groups to coordinate StandardName usage.</li> <li>Keep a list of StandardNames that you introduce and give them to a CAM SE for incorporation into an upcoming CCPPStandardNames PR</li> <li>If you create your own name (for now), add <code>_TBD</code> to the end fo the name to signify that it has not been discussed yet</li> </ul> </li> </ul> </li> </ul> <p>Updated standard names</p> <p>If, in the course of your implementation or during code review to the CCPPStandardNames repository, the standard name changes, please update the name in the spreadsheet to reflect the change!</p> <ul> <li>units: the units can be found in the standard names spreadsheet as well (<code>Snapshot Units</code> column)<ul> <li>You can find additional rules for units in the ESMStandardNames repository</li> </ul> </li> <li>dimensions: Refer to the table below<ul> <li>If you have module level variables (variables above the \"contains\" line in a module file) which are declared with dimension <code>pver</code> or <code>pverp</code>, then you need to make this variable be allocatable and allocate the variable in the init routine.  This is due to the fact that pver is not known at compilation time, but is rather a run-time option in CAM-SIMA</li> <li>Note for pcols inside parameterizations:  As only active columns will be passed to the parameterizations, there is no need for a maximum size variable anymore</li> <li>In the template, you can convert <code>enter_standard_nameXX:enter_standard_nameYY</code> to just  use the appropriate dimension_name or do <code>1:dimension_name</code> (both work)</li> </ul> </li> </ul> CAM dimension CCPP phase standard_name pver all vertical_layer_dimension pverp (or pver+1) all vertical_interface_dimension ncols or pcols non-run phase horizontal_dimension ncols or pcols run phase horizonal_loop_extent pcnst all number_of_ccpp_constituents <ul> <li>optional arguments: If there are optional arguments, consult with a CAM SE. Optional attributes are an unsupported configuration, but are being incorporated into the framework. That said, there may be a workaround to avoid the use of optional arguments in your scheme</li> <li>Note: Try to avoid module level allocations and/or assignments even in the init phases of the code.  If you believe you need to do this, speak with a Jesse and/or Cheryl for guidance</li> </ul> <p>Once you have created your metadata, proceed to 3 - Create namelist XML file</p>"},{"location":"conversion/create-metadata/#error-variables","title":"Error variables","text":"<p>See below for error variable metadata</p> <pre><code>[ errmsg ]\n  standard_name = ccpp_error_message\n  long_name = Error message for error handling in CCPP\n  units = none\n  type = character | kind = len=512\n  dimensions = ()\n  intent = out\n[ errflg ]\n  standard_name = ccpp_error_code\n  long_name = Error flag for error handling in CCPP\n  units = 1\n  type = integer\n  dimensions = ()\n  intent = out\n</code></pre>"},{"location":"conversion/create-metadata/#constituents","title":"Constituents","text":"<p>See constituent usage. You can tell a variable is a constituent if it is in the <code>state%q</code> array in CAM (may have to trace back in the code a bit)</p>"},{"location":"conversion/create-metadata/#dependencies","title":"Dependencies","text":"<p>If your scheme has any \"use\" statements (helper functions, approved dependencies), add a <code>dependencies</code> field with a common-separated list of relative paths to the necessary modules to the top of your metadata file. Example:</p> <pre><code>[ccpp-table-properties]\n  name = musica_ccpp\n  type = scheme\n  dependencies = micm/musica_ccpp_micm.F90,musica_ccpp_util.F90\n</code></pre>"},{"location":"conversion/create-namelist-xml/","title":"3 - Create namelist XML file","text":"<p>If your scheme has a <code>readnl</code> scheme, create an .xml file with the same name as the scheme which uses the namelist (place it in the same location as the parameterization in <code>ncar_ccpp</code>.</p> <ul> <li>The filename should be <code>&lt;scheme&gt;_namelist.xml</code></li> <li>If you have metadata entries for these namelist entries from your previous conversion steps, it may be useful to copy the metadata entry and edit it to be xml.  If you do this, you will delete the dimensions and intent lines and add category, group, desc and values/value.</li> </ul> <p>The CCPP Framework will autogenerate the namelist reader based on the elements in the namelist XML file associated with the parameterization.  Each namelist element (<code>&lt;entry_id&gt;</code>) will have the following fields: <code>&lt;id&gt;</code> <code>&lt;type&gt;</code>, <code>&lt;category&gt;</code>, <code>&lt;group&gt;</code>, <code>&lt;standard_name&gt;</code>, <code>&lt;units&gt;</code>, <code>&lt;desc&gt;</code> and <code>&lt;values&gt;</code>.  Note that all variables in the namelist should appear in the parameterization\u2019s <code>_init</code> subroutine interface. The description of each field is as follows:</p> <ul> <li>id: The namelist variable's name. The name must be lower case. The module converts all namelist variable names to lower case since Fortran is case insensitive.</li> <li>type:  An abbreviation of the fortran declaration for the variable. Any of these types may be followed by a comma separated list of integers enclosed in parentheses to indicate an array. The current namelist validation code only distinguishes between string and non-string types. Valid declarations are:<ul> <li>char*n</li> <li>integer</li> <li>logical</li> <li>real</li> </ul> </li> <li>kind: Only needed if type is real (if type is real, 'kind' will be 'kind_phys')</li> <li>input_pathname (optional): Only include this attribute to indicate that the variable contains the pathname of an input dataset that resides in the CESM inputdata directory tree. Note that the variables containing the names of restart files that are used in branch runs don't reside in the inputdata tree and should not be given this attribute. The recognized values are:<ul> <li>\"abs\" to indicate that an absolute pathname is required, or</li> <li>\"rel:var_name\" to indicate that the pathname is relative and that the namelist variable \"var_name\" contains the absolute root directory</li> </ul> </li> <li>category: A category assigned for organized the documentation. This can be found by copying from the <code>bld/namelist_files/namelist_definition.xml</code> file in CAM</li> <li>group: The namelist group that the variable is declared in (found in <code>&lt;parameterization&gt;_readnl</code> in CAM)</li> <li>standard_name: The CCPP standard name</li> <li>units: Units for the variable. Must adhere to CCPP units convention (link?)</li> <li>desc: The description for this namelist variable.  This can be found by copying from the <code>bld/namelist_files/namelist_definition.xml</code> file in CAM.  This is parsed and used in the creation of the CAM namelist web page.  Description should be adequate for this purpose (**Maybe not? This is implemented in SIMA yet...).</li> <li>value: Initial value for the variable. This can be a valid default value or an out-of-range value to allow for trapping in the code.</li> <li>valid_values (optional): Attribute that is mainly useful for variables that have only a small number of allowed values.</li> </ul> <p>Example Namelist XML file</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n\n\n&lt;?xml-stylesheet type=\"text/xsl\" href=\"namelist_definition.xsl\"?&gt;\n\n\n&lt;entry_id_pg version=\"2.0\"&gt;\n\n\n  &lt;entry id=\"cldfrc_premit\"&gt;\n    &lt;type&gt;real&lt;/type&gt;\n    &lt;category&gt;cldfrc&lt;/category&gt;\n    &lt;group&gt;cldfrc_nl&lt;/group&gt;\n    &lt;standard_name&gt;tunable_parameter_for_top_pressure_bound_for_mid_level_clouds_for_cloud_fraction&lt;/standard_name&gt;\n    &lt;units&gt;Pa&lt;/units&gt;\n    &lt;desc&gt;\n      Top pressure bound for mid level cloud.\n    &lt;/desc&gt;\n    &lt;values&gt;\n      &lt;value dyn=\"mpas\"&gt;75000.0D0&lt;/value&gt;\n      &lt;value dyn=\"se\"&gt;40000.0D0&lt;/value&gt;\n      &lt;value&gt;40000.0D0&lt;/value&gt;\n    &lt;/values&gt;\n  &lt;/entry&gt;\n\n\n&lt;/entry_id_pg&gt;\n</code></pre> <p>namelist values</p> <p>When porting namelist values from CAM namelist defaults, the attributes supported in CAM-SIMA can be retrieved by printing out <code>cam_nml_dict</code> (or <code>cam_nml_dict.keys()</code>) in <code>cime_config/buildnml</code> at the end of the function call. An example of supported attributes that may be commonly used are: <code>phys_suite</code>, <code>ic_ymd</code>, <code>dyn</code>, <code>hgrid</code>, <code>analytic_ic</code>, <code>ocn</code>.</p> <p>Once you have made your namelist file, proceed to 4 - Interstitials</p>"},{"location":"conversion/create-sdf/","title":"5 - Create an SDF","text":"<p>The Suite Definition File (SDF) tells the CCPP-Framework which schemes will be run in what order. For more, see CCPP in CAM-SIMA</p> <ul> <li> <p>In <code>$CAM-SIMA/src/physics/ncar_ccpp/test/test_suites</code>, create <code>suite_&lt;parameterization&gt;.xml</code>. This is your SDF!</p> <p>SDF location</p> <p>If your parameterization or CCPPization represents a complete configuration that can be run by normal users (e.g. a simple physics package like kessler), instead put your SDF in <code>$CAM-SIMA/src/physics/ncar_ccpp/suites</code>.Most likely, your parameterization will not fall into this category and will \"just\" be part of an existing suite like <code>CAM4</code> or <code>CAM7</code>, meaning you should put the SDF in the <code>test_suite</code> directory listed above.</p> </li> <li> <p>See the template below. You will need to select either <code>physics_before_coupler</code> or <code>physics_after_coupler</code> as your group name, according to the table below.</p> </li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;suite name=\"&lt;parameterization&gt;\" version=\"1.0\"&gt;  \n   &lt;group name=\"physics_X_coupler\"&gt;  \n       &lt;scheme&gt;&lt;parameterization&gt;&lt;/scheme&gt;\n   &lt;/group&gt;\n&lt;/suite&gt;\n</code></pre> CAM physpkg routine CAM-SIMA SDF Group Description tphysbc physics_before_coupler Physics schemes run before the surface coupler is called tphysac physics_after_coupler Physics schemes run after the surface coupler is called <ul> <li>Add any interstitials which you\u2019ve created or are using in the appropriate location relative to your parameterization</li> </ul> <p>For example: if your parameterization requires dry water vapor, you'll want to add:</p> <ul> <li><code>&lt;scheme&gt;wet_to_dry_water_vapor&lt;/scheme&gt;</code> before your core parameterization scheme to convert water vapor to a dry mixing ratio (CAM-SIMA has \"wet\")</li> <li><code>&lt;scheme&gt;dry_to_wet_water_vapor&lt;/scheme&gt;</code> after your parameterization scheme to convert back to a wet mixing ratio to return to CAM-SIMA</li> </ul> <p>CAMX physics suite</p> <p>You will also need to add your same set of schemes to the appropriate larger suite (usually <code>suite_cam7.xml</code>). Use comments to delineate your set(s) of schemes to make the SDF somewhat readable.</p> <p>Once you have created your SDF, proceed to 6 - Create snapshots of CAM</p>"},{"location":"conversion/create-snapshots/","title":"6 - Create snapshots of CAM","text":""},{"location":"conversion/create-snapshots/#cam-snapshot-run-tips","title":"CAM snapshot run tips","text":"<ol> <li>Try to use the lowest resolution grid possible in order to keep the snapshot file size small (e.g. <code>ne3pg3_ne3pg3_mg37</code>).</li> <li>Run with debug flags on (<code>./xmlchange DEBUG=True</code>), as this way errors that can occur when you bring the CCPP-ized code back into CAM are easier to catch. Make sure ALL CAM and CAM-SIMA runs have debug on.</li> <li>You should generate at least one set of snapshot files using GNU on derecho with DEBUG=TRUE, as these will be saved for use in the CAM-SIMA physics testbed to prevent unexpected answer changes.</li> </ol>"},{"location":"conversion/create-snapshots/#configure-and-set-up-cam-snapshot","title":"Configure and set-up CAM snapshot","text":"<p>Make a normal CAM (not CAM-SIMA) run using cam_snapshot to capture before and after files using a compset which exercises the parameterization being converted.</p> <ul> <li> <p>The cam_snapshot feature dumps the entire state/tend/pbuf/cnst arrays to netCDF files.</p> <ul> <li>The variables <code>cam_snapshot_before_num</code> and <code>cam_snapshot_after_num</code> are the output file numbers (offset by 1 as they are in CAM).</li> <li>The <code>cam_take_snapshot_before</code> and <code>cam_take_snapshot_after</code> are usually set to the same parameterization to capture the variables before and after the named parameterization.<ul> <li>To find the snapshot name, look in your source code checkout in <code>bld/namelist_files/namelist_definition.xml</code>.<ul> <li>Inside this file, find the \u201ccam_take_snapshot_before\u201d definition.  In this definition, it lists all possible parameterizations which can have a snapshot file created around.<ul> <li>If your parameterization is there, that will be your <code>cam_take_snapshot_before</code> and <code>_after</code> values in your <code>user_nl_cam</code></li> <li>If it's not there, you'll add <code>user_set</code> snapshot calls to <code>physpkg.F90</code> per the instructions here</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>To enable cam_snapshot, add the following to your user_nl_cam file:</p> </li> </ul> <pre><code>cam_snapshot_before_num=6\ncam_snapshot_after_num=7\ncam_take_snapshot_before='&lt;parameterization&gt;_tend' ! or 'user_set'\ncam_take_snapshot_after='&lt;parameterization&gt;_tend' ! or 'user_set'\nnhtfrq = 0,0,0,0,0,1,1\nndens = 2,2,2,2,2,1,1\n</code></pre> <ul> <li>The \u201cbefore\u201d file will be used for input for testing; \u201cafter\u201d file will be used for comparisons</li> <li>Make sure to avoid using tape number one (h0) for <code>cam_snapshot_before_num</code> and <code>cam_snapshot_after_num</code></li> <li>Check your namelist for any extra \u201cfincl\u201d settings added by use cases, as those will add variables that can conflict with the snapshot output.<ul> <li>To check this, before you modify the <code>user_nl_cam</code> file,  run <code>./case.setup</code>, run <code>./preview_namelists</code> and then look at the resulting <code>atm_in</code> file in the run directory. Look for <code>finclX</code> where X is your possible \u201cbefore\u201d and \u201cafter\u201d numbers.  Choose a number that is not used.<ul> <li>You most likely will see fincl1 which is why it is not an option. </li> </ul> </li> </ul> </li> <li>Set nhtfrq to 1 so that data is written out on every time step.  Note that the nhtfrq and ndens variables are arrays based off of the \u201ctape\u201d number specified in <code>cam_snapshot_before</code> and <code>cam_snapshot_after</code>.  (i.e. 6 = the sixth number in these two arrays)</li> <li>Finally, as cam_snapshot writes out all of state, pbuf and other variables at every time step, it is suggested that a limited number of time steps be made in a cam_snapshot run.<ul> <li>The run must be at least 2 time steps in order to work in subsequent steps. We recommend 3 to at most 9 time steps.  (Note a 3 timestep run using a 2 degree FV grid can produce snapshot files with sizes over 4 Gb each).</li> <li>To change the number of timesteps to 3 use <code>./xmlchange STOP_OPTION=nsteps</code> and <code>./xmlchange STOP_N=3</code></li> </ul> </li> </ul> <p>Coupling frequency</p> <p>With short NUOPC runs, you may need to change ROF_NCPL and/or GLC_NCPL to the same size at ATM_NCPL to get them to run properly (<code>./xmlchange ROF_NCPL=\\$ATM_NCPL</code> and <code>./xmlchange GLC_NCPL=\\$ATM_NCPL</code>)</p>"},{"location":"conversion/create-snapshots/#create-cam-snapshots","title":"Create CAM snapshots","text":"<p>Run CAM normally with </p> <pre><code>./case.setup\n./case.build\n./case.submit\n</code></pre> <p>Upon a successful completion, you will see a <code>cam.h5i.xxx.nc</code> and <code>cam.h6i.xxx.nc</code> in your run directory (assuming you used before and after of 6 and 7)</p>"},{"location":"conversion/create-snapshots/#save-snapshot-files","title":"Save snapshot files","text":"<p>The generated snapshot files should be saved on derecho here:</p> <pre><code>/glade/campaign/cesm/community/amwg/sima_baselines/cam_sima_test_snapshots\n</code></pre> <p>with the naming convention <code>cam_&lt;resolution&gt;_&lt;parameterization&gt;_snapshot_derecho_&lt;compiler&gt;_before_cYYYYMMDD.nc</code> and <code>cam_&lt;resolution&gt;_&lt;parameterization&gt;_snapshot_derecho_&lt;compiler&gt;_after_cYYYYMMDD.nc</code></p> <p>Be sure to run</p> <pre><code>chmod u=rw,g=r,o=r &lt;snapshot_files&gt;\n</code></pre> <p>or</p> <pre><code>chmod 644 &lt;snapshot_files&gt;\n</code></pre> <p>on every file you copy over so that it is readable by everyone</p> <p>On izumi, save your converted snapshot files in:</p> <pre><code>/project/amp02/cam_snapshot_files/&lt;parameterization&gt;\n</code></pre> <p>Once you have created your snapshot files, proceed to 7 - Run CAM-SIMA</p>"},{"location":"conversion/create-snapshots/#user-set-snapshot-calls","title":"\"user set\" snapshot calls","text":"<p>Depending on where your scheme is called within CAM physics (in CAM6 or CAM7 physpkg and in tphysac or tphysbc), choose a code snippet below.</p> <p>Snapshot call changes</p> <p>If the snapshot calls change in CAM, this section may not be updated immediately. If you're running into issues, mirror an existing set of snapshot calls in the physpkg.F90 routine you are working in.</p>"},{"location":"conversion/create-snapshots/#cam7-tphysbc","title":"CAM7 tphysbc","text":"<p>In <code>$CAM/src/physics/cam7/physpkg.F90</code>:</p> <pre><code>if (trim(cam_take_snapshot_before) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysbc(cam_snapshot_before_num, state, tend, cam_in, cam_out, pbuf, &amp;\n           cmfmc, cmfcme, zdu, rliq, rice, dlf, dlf2, rliq2, net_flx)\nend if\n\n&lt;call to parameterization run phase&gt;\n\nif ( (trim(cam_take_snapshot_after) == \"user_set\") .and. &amp;\n     (trim(cam_take_snapshot_before) == trim(cam_take_snapshot_after))) then\n        call cam_snapshot_ptend_outfld(ptend, lchnk)\nend if\n\n&lt;call to physics_update and/or ptend outfld calls&gt;\n\nif (trim(cam_take_snapshot_after) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysbc(cam_snapshot_after_num, state, tend, cam_in, cam_out, pbuf, &amp;\n           cmfmc, cmfcme, zdu, rliq, rice, dlf, dlf2, rliq2, net_flx)\nend if\n</code></pre>"},{"location":"conversion/create-snapshots/#cam7-tphysac","title":"CAM7 tphysac","text":"<p>In <code>$CAM/src/physics/cam7/physpkg.F90</code></p> <pre><code>if (trim(cam_take_snapshot_before) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysac(cam_snapshot_before_num, state, tend, cam_in, cam_out, pbuf,&amp;\n                    fh2o, surfric, obklen, flx_heat, cmfmc, dlf, det_s, det_ice, net_flx)\nend if\n\n&lt;call to parameterization run phase&gt;\n\nif ( (trim(cam_take_snapshot_after) == \"user_set\") .and.      &amp;\n     (trim(cam_take_snapshot_before) == trim(cam_take_snapshot_after))) then\n   call cam_snapshot_ptend_outfld(ptend, lchnk)\nend if\n\n&lt;call to physics_update and/or ptend outfld calls&gt;\n\nif (trim(cam_take_snapshot_after) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysac(cam_snapshot_after_num, state, tend, cam_in, cam_out, pbuf,&amp;\n                    fh2o, surfric, obklen, flx_heat, cmfmc, dlf, det_s, det_ice, net_flx)\nend if\n</code></pre>"},{"location":"conversion/create-snapshots/#cam6-tphysbc","title":"CAM6 tphysbc","text":"<p>In <code>$CAM/src/physics/cam/physpkg.F90</code>:</p> <pre><code>if (trim(cam_take_snapshot_before) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysbc(cam_snapshot_before_num, state, tend, cam_in, cam_out, pbuf, &amp;\n           flx_heat, cmfmc, cmfcme, zdu, rliq, rice, dlf, dlf2, rliq2, det_s, det_ice, net_flx)\nend if\n\n&lt;call to parameterization run phase&gt;\n\nif ( (trim(cam_take_snapshot_after) == \"user_set\") .and.      &amp;\n     (trim(cam_take_snapshot_before) == trim(cam_take_snapshot_after))) then\n   call cam_snapshot_ptend_outfld(ptend, lchnk)\nend if\n\n&lt;call to physics update and/or ptend outfld calls&gt;\n\nif (trim(cam_take_snapshot_after) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysbc(cam_snapshot_after_num, state, tend, cam_in, cam_out, pbuf, &amp;\n           flx_heat, cmfmc, cmfcme, zdu, rliq, rice, dlf, dlf2, rliq2, det_s, det_ice, net_flx)\nend if\n</code></pre>"},{"location":"conversion/create-snapshots/#cam6-tphysac","title":"CAM6 tphysac","text":"<p>In <code>$CAM/src/physics/cam/physpkg.F90</code>: </p> <pre><code>if (trim(cam_take_snapshot_before) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysac(cam_snapshot_before_num, state, tend, cam_in, cam_out, pbuf,&amp;\n                    fh2o, surfric, obklen, flx_heat)\nend if\n\n&lt;call to parameterization run phase&gt;\n\nif ( (trim(cam_take_snapshot_after) == \"user_set\") .and.      &amp;\n     (trim(cam_take_snapshot_before) == trim(cam_take_snapshot_after))) then\n   call cam_snapshot_ptend_outfld(ptend, lchnk)\nend if\n\n&lt;call to physics update and/or ptend outfld calls&gt;\n\nif (trim(cam_take_snapshot_after) == \"user_set\") then\n   call cam_snapshot_all_outfld_tphysac(cam_snapshot_after_num, state, tend, cam_in, cam_out, pbuf,&amp;\n                    fh2o, surfric, obklen, flx_heat)\nend if\n</code></pre>"},{"location":"conversion/final-steps/","title":"10 - Final steps","text":"<p>Open PRs to the relevant repositories. The order specified here (atmospheric_physics, CAM, then CAM-SIMA) is the preferred ordering of PRs/testing/merging. The reason for this is that atmospheric_physics has to go first to get a tag for both CAM and CAM-SIMA. Then the robust testing within CAM will validate the physics, resulting in increased confidence for bringing it into CAM-SIMA.</p> <p>It is also good practice to not let there be too much time between merging your atmospheric_physics PR and your CAM-SIMA PR, as the CAM-SIMA registry and the physics metadata are very closely linked and can cause problems for other developers if they are out of sync.</p>"},{"location":"conversion/final-steps/#atmospheric_physics","title":"atmospheric_physics","text":"<p>Follow the atmospheric_physics workflow to open a PR, respond to review requests, and populate the <code>NamesNotInDictionary.txt</code> file.</p> <p>Note</p> <p>Before finalizing the atmospheric_physics pull request, compare the latest CAM tag with the CAM tag you started with when moving code from CAM to atmospheric_physics to check if any changes to moved code was introduced in CAM.</p>"},{"location":"conversion/final-steps/#cam","title":"CAM","text":"<p>Follow the CAM workflow to open a PR and respond to review requests. Be sure to include the <code>ccpp-conversion</code> label on your PR. Once you are assigned a tag by the gatekeeper, run the tests, update the Changelog, then make the tag and archive the baselines.</p>"},{"location":"conversion/final-steps/#cam-sima","title":"CAM-SIMA","text":"<ol> <li>Add a new test for your scheme using the before/after snapshots you generated during conversion. You can parallel existing FPHYStest tests and follow the instructions here.</li> <li>Follow the CAM-SIMA workflow to open a PR, run the regression tests, and (potentially) make a tag. At the very least, you will have the testing updates above and a new atmopsheric_physics hash (which will point to your fork until the atmospheric_physics PR is merged).</li> </ol>"},{"location":"conversion/final-steps/#final-touches","title":"Final touches","text":"<ol> <li>Once all PRs are merged and tagged, check off the scheme as \"Converted\" in the spreadsheet.</li> </ol>"},{"location":"conversion/interstitials/","title":"4 - Interstitials","text":""},{"location":"conversion/interstitials/#overview","title":"Overview","text":"<p>An interstitial is a scheme that does calculations or variable modifications to connect what the host model has to what the scheme requires and vice versa.</p> <ul> <li>These schemes are placed before or after the core parameterization scheme in the suite definition file (SDF) to prep for the scheme or take what the scheme produces and translate it back to what the host model (CAM-SIMA) expects</li> <li>In CAM, interstitial code will appear as either function calls or calculations/modifications in the CAM interface just before or just after the call to the parameterization<ul> <li>If the interstitial code is a function call, that function/module should be CCPP-ized (if not already) and that scheme will be included in the SDF</li> <li>It the interstitial code is loose in the CAM interface, it is recommended that, when possible, that code be moved into the scheme (either the beginning or end of the scheme subroutine)<ul> <li>UNLESS: it's a common (across multiple parameterizations) calculation/translation/modification. In which case, a new scheme should be created to do that calculation (scheme will live in <code>$CAM-SIMA/src/physics/ncar_ccpp/schemes/utilities</code>)</li> <li>If it is absolutely necessary to create a scheme-specific interstitial, that scheme should be called <code>&lt;parameterization&gt;_pre</code> or <code>_post</code> (depending on where in the SDF it will be placed) and will live in the <code>ncar_ccpp/schemes/&lt;parameterization&gt;</code> directory</li> </ul> </li> </ul> </li> </ul> <p>This section covers a few interstitial scenarios you are likely to face.</p>"},{"location":"conversion/interstitials/#diagnostics-interstitial","title":"Diagnostics interstitial","text":"<p>All <code>addfld</code>/<code>outfld</code> calls will go in a <code>&lt;parameterization&gt;_diagnostic.F90</code> interstitial. You can find a template and instructions for scheme-specific diagnostics here:</p> <ul> <li><code>addfld</code> calls will go into the <code>&lt;parameterization&gt;_diagnostic_init</code> subroutine</li> <li><code>outfld</code> calls will go into the <code>&lt;parameterization&gt;_diagnostic_run</code> subroutine</li> <li>The interstitial itself will reside after the <code>&lt;parameterization&gt;</code> line in the SDF<ul> <li>See: History Usage for the specifications of the CAM-SIMA-versions of <code>addfld</code> and <code>outfld</code> calls</li> </ul> </li> </ul>"},{"location":"conversion/interstitials/#utilities","title":"Utilities","text":"<p>As mentioned, there are some calculations/conversions/translations that are performed often throughout the physics code in CAM. These schemes are available for use in the <code>$CAM-SIMA/src/physics/ncar_ccpp/schemes/utilities</code> directory and include:</p> <ul> <li>state_converters.F90: contains common conversions/calculations of state variables, including these schemes:</li> </ul> Scheme name Description Output variable Input variables temp_to_potential_temp convert temperature to potential temperature air_potential_temperature air_temperatureinverse_exner_function potential_temp_to_temp convert potential temperature to temperature air_temperature air_potential_temperatureinverse_exner_function calc_dry_air_ideal_gas_density Calculate density from equation of state/ideal gas law dry_air_density composition_dependent_gas_constant_of_dry_airair_pressure_of_dry_airair_temperature calc_exner calculate dimensionless exner function dimensionless_exner_function composition_dependent_specific_heat_of_dry_air_at_constant_pressurecomposition_dependent_gas_constant_of_dry_airsurface_reference_pressureair_pressure wet_to_dry_water_vapor convert water vapor from wet to dry mixing ratio water_vapor_mixing_ratio_wrt_dry_air air_pressure_thicknessair_pressure_thickness_of_dry_airwater_vapor_mixing_ratio_wrt_moist_air_and_condensed_water dry_to_wet_water_vapor convert water vapor from dry to wet mixing ratio water_vapor_mixing_ratio_wrt_moist_air_and_condensed_water air_pressure_thicknessair_pressure_thickness_of_dry_airwater_vapor_mixing_ratio_wrt_dry_air wet_to_dry_cloud_liquid_water convert cloud liquid from wet to dry mixing ratio cloud_liquid_water_mixing_ratio_wrt_dry_air air_pressure_thicknessair_pressure_thickness_of_dry_aircloud_liquid_water_mixing_ratio_wrt_moist_air_and_condensed_water dry_to_wet_cloud_liquid_water convert cloud liquid from dry to wet mixing ratio cloud_liquid_water_mixing_ratio_wrt_moist_air_and_condensed_water air_pressure_thicknessair_pressure_thickness_of_dry_aircloud_liquid_water_mixing_ratio_wrt_dry_air wet_to_dry_rain convert rain from wet to dry mixing ratio rain_mixing_ratio_wrt_dry_air air_pressure_thicknessair_pressure_thickness_of_dry_airrain_mixing_ratio_wrt_moist_air_and_condensed_water dry_to_wet_rain convert rain from dry to wet mixing ratio rain_mixing_ratio_wrt_moist_air_and_condensed_water air_pressure_thicknessair_pressure_thickness_of_dry_airrain_mixing_ratio_wrt_dry_air <ul> <li>geopotential_temp.F90: <ul> <li>geopotential_temp: compute geopotential height (<code>geopotential_height_wrt_surface</code>) and geopotential height at interfaces (<code>geopotential_height_wrt_surface_at_interface</code>) from temperature (<code>air_temperature</code>)</li> </ul> </li> <li>static_energy.F90<ul> <li>update_dry_static_energy: calculate dry static energy (<code>dry_static_energy</code>)</li> </ul> </li> <li> <p>qneg.F90:</p> <ul> <li>qneg: Set values for constituent variables that are less than the minimum value to the minimum value (and print out what it's doing - configurable!)</li> <li>You will want to include qneg in your SDF if you are modifying constituent tendencies in your scheme. It should be after the tendencies are applied and before <code>geopotential_temp</code></li> <li> <p>If <code>qneg</code> is in your SDF, you will need to provide the output variable <code>scheme_name</code> in your physics parameterization that is modifying constituent tendencies</p> <p>scheme_name variable</p> <p>If you skip this step, you will get either <code>parse_source.CCPPError: Input argument for qneg_run, scheme_name, not found</code>, or an incorrect scheme_name from a previous routine will be used</p> </li> </ul> </li> <li> <p>physics_tendency_updaters.F90: apply tendencies output by physics to state variables. You'll need to include a tendency updater in your SDF for any <code>ptend%X</code> variables in the CAM-version of your code.</p> </li> </ul> Scheme name Description inout variables onput variables apply_tendency_of_eastward_wind Apply the eastward wind tendency calculated in the previous physics scheme(s) to the <code>eastward_wind</code> state variable eastward_windtendency_of_eastward_wind tendency_of_eastward_wind_\u2002\u2002due_to_model_physicstimestep_for_physics apply_tendency_of_northward_wind Apply the northward wind tendency calculated in the previous physics scheme(s) to the <code>northward_wind</code> state variable northward_windtendency_of_northward_wind tendency_of_northward_wind_\u2002\u2002due_to_model_physicstimestep_for_physics apply_heating_rate Apply the heating rate (<code>tendency_of_dry_air_enthalpy_at_constant_pressure</code>) to the temperature tendency and temperature state variable air_temperaturetendency_of_air_temperature_\u2002\u2002due_to_model_physicsheating_rate tendency_of_dry_air_enthalpy_\u2002\u2002at_constant_pressurecomposition_dependent_specific_heat_\u2002\u2002of_dry_air_at_constant_pressuretimestep_for_physics apply_tendency_of_air_temperature Apply the temperature tendency calculated in the previous physics scheme(s) to the <code>air_temperature</code> state variable air_temperaturetendency_of_air_temperature tendency_of_air_temperature_\u2002\u2002due_to_model_physicstimestep_for_physics apply_constituent_tendencies Apply the constituent tendencies calculated in the previous physics scheme(s) to the constituent state array ccpp_constituentsccpp_constituent_tendencies timestep_for_physics <p>Proceed to 5 - Create an SDF. </p> <p>Warning</p> <p>You may have to revisit this step as you debug your code.</p>"},{"location":"conversion/run-cam-sima/","title":"8 - Run CAM-SIMA","text":"<p>It's time to try to run CAM-SIMA!</p>"},{"location":"conversion/run-cam-sima/#configure-cam-sima","title":"Configure CAM-SIMA","text":"<ul> <li>Either navigate to the case you created when you were validating your metadata or create a new case</li> <li>Your <code>user_nl_cam</code> needs to contain the following (to bring in the cam_snapshot for input and to activate the validation tool):</li> </ul> <pre><code>ncdata='/FullPathName/your_before_snapshot_file.nc'\nncdata_check='/FullPathName/your_after_snapshot_file.nc'\ndebug_output = 0  !Turns off debug messages which interfere with the validation tool output\n</code></pre> <ul> <li> <p>If the number of vertical levels in your snapshot file is something other than 30, then you will also need to add the following to your user_nl_cam:</p> <p><code>pver = N</code></p> <p>where \u201cN\u201d is the number of vertical levels in your snapshot file (likely 32 levels for CAM6)</p> </li> </ul>"},{"location":"conversion/run-cam-sima/#build-and-run","title":"Build and run","text":"<ul> <li>Run <code>./case.build</code> and <code>./case.submit</code><ul> <li>Consult the table below for common errors. Also see debugging tips for help if you're getting errors</li> </ul> </li> </ul> <p>Rebuilding CAM-SIMA</p> <p>If you've modified any metadata between builds, you will need to run <code>./case.build --clean-all</code> before rebuilding.</p> Error text Description Possible Fix <code>ERROR: cam_get_file: FAILED to get UNSET_PATH</code> No initial data file specified (or defaulted to) Specify <code>ncdata = '&lt;file&gt;'</code> in your user_nl_cam file <code>ERROR: read_field_3d: No variable found in (/XXX, /)</code> Variable not found when we're reading in the initial data or snapshot file <ul><li>Double-check your standard name</li><li>Determine if CAM-SIMA needs to handle/initialize the variable. If it does, follow the procedure for the error below</li></ul> <code>ERROR: Cannot read XXX from file, XXX has no horizontal dimension</code> Variable is a scalar; we don't have an interface to read it in from a file (and it's not likely to be present on the file) <ul><li>If \"XXX\" is static during the run, add <code>access=\"protected\"</code> to the variable's XML entry in the registry</li><li>if the variable is not static, either:<ul><li>Initialize the variable in the init phase of your scheme (<code>intent=out</code>), or</li><li>initialize \"XXX\" in CAM-SIMA (NOT in the physics code) and add a call to <code>mark_as_initialized(&lt;standard_name&gt;)</code> so CAM-SIMA doesn't try to read in the variable</li></ul> <code>ERROR in '&lt;path/to/cesm.exe&gt;': corrupted size vs. prev_size: 0xXXXXXXXXXXXXXX</code> Possibly an out of bounds error <ul><li>Find the line that the stack trace is pointing to (likely in the generated code) and trace the variable in question, looking for out-of-bounds errors<ul><li>Specifically, check that the variable has the correct dimensions in the metadata (e.g. vertical_layer_dimension vs vertical_interface_dimension)</li></ul></li><li>Also, check the variables immediately before and after the line for out-of-bounds errors (we have seen this error reported on the line immediately before the problem line).</li><li>Try running in DEBUG mode if not already to include bounds checking</li></ul> <ul> <li>Once the model completes without error, the results from the validation tool will appear in the <code>atm_log</code> file for each timestep (under the header <code>********** Physics Check Data Results **********</code>)<ul> <li>The message <code>No differences found!</code> should be logged for each timestep.</li> <li>If there are differences found, that indicates there are issues with your ported code</li> <li>See the section on Tips for uncovering unexpected answer changes for debugging strategies</li> </ul> </li> </ul> <p>Additional step for NAG compiler</p> <p>If we have a working NAG compiler with CAM-SIMA (not working as of 12/17/2024), perform this extra step:</p> <ul> <li>Make at least one run using the NAG compiler on izumi in debug mode and specifying \u201c-nan\u201d as an additional compilation option.  This option initializes all variables to NaN so that if something is uninitialized and is used, it will be trapped.  To enable this flag:<ul> <li>After executing the ./create_newcase and ./case.setup commands and BEFORE executing the ./case.build, edit the file in your case directory <code>cmake_macros/nag.cmake</code> (- If you want to change the file so that it runs every time you execute a <code>./create_newcase</code>, you can find the file at <code>ccs_config/machines/cmake_macros/nag.cmake</code>). </li> <li>Change the line Append line so that it contains \u2018-nan\u2019 and it should look like this: <code>if (DEBUG)    string(APPEND FFLAGS \" -nan -C=all -g -time -f2003 -ieee=stop\") endif()</code></li> </ul> </li> </ul> <p>Once you have successfully run CAM-SIMA and all answer changes have either accepted or fixed, proceed to 9 - Bring back into CAM</p>"},{"location":"conversion/run-cam-sima/#tips-for-uncovering-unexpected-answer-changes","title":"Tips for uncovering unexpected answer changes","text":"<ul> <li>Make sure that your snapshot is taken with an updated atmospheric_physics, especially if answers changed during development</li> <li>Check all of your standard_names.  CAM-SIMA will run successfully, but if a standard_name is incorrect, you may be running with an incorrect variation of the variable that you intended</li> <li>If comparing printed values on the physics grid between CAM and CAM-SIMA, then it might be good to turn-off chunking in CAM, which can be done by setting <code>-pcols</code> in <code>CAM_CONFIG_OPTS</code> to be a large number (e.g. &gt;500 for the ne3 grid): <code>./xmlchange CAM_CONFIG_OPTS=\"-pcols 1352\" --append</code> (use the <code>--append</code> option to not lose existing options.)<ul> <li>You can also utilize the <code>tools/find_max_nonzero_index.F90</code> tool to (more) easily compare values between CAM and CAM-SIMA at a specific rank and index that is known to be non-zero</li> </ul> </li> <li>Note that the way latitude in radians is calculated for the null dycore in CAM-SIMA is different (at a round-off level) to the way it is calculated in the SE dycore in CAM.  This means if you are validating a physics scheme that has latitude (in radians) as an input, then in CAM you\u2019ll need to change the scheme interface to read in latitude in degrees, and then convert to radians by multiplying by pi/180 (which you\u2019ll only want to do when creating the snapshot file, not when validating CAM itself).</li> <li>Sometimes CAM-SIMA will set a state variable directly, while CAM will only set a tendency variable and then use the \u201cphysics_update\u201d routine to update the state using the tendency.  This can result in round-off level differences.  If this happens then simply try setting the state variable directly in CAM when creating the snapshot files for CAM-SIMA testing.</li> <li>Namelist settings may be incompatible with what is being run in CAM-SIMA with it being a single physics package versus the complete CAM code. For instance, a normal CAM run may have a default namelist setting and then a different value for \"clubb_sgs=1 microphys=mg3\" which is what a CAM7 run would be. To temporarily work around this, set the values which are evaluating incorrectly in your <code>user_nl_cam</code> file for CAM-SIMA to the values which match a CAM run.  The easy way to find these is to compare your <code>atm_in</code> values with your CAM and CAM-SIMA runs and add the appropriate settings.</li> <li> <p>Compare numbers between a run in CAM and another in CAM-SIMA. A debug run with the <code>--pecount 1</code> argument provided to create_newcase gives you an executable which works well in the Totalview debugger.</p> <p>timestep discrepancy</p> <p>The cam_snapshot file will be written starting with the second timestep, so your CAM run will need to advance past the first timestep before you can start comparing.</p> </li> <li> <p>If you find that you have to comment out pieces of code in CAM to get your snapshot tests to work (not ideal, but has happened a few times!), be sure to commit your source mods to a new subdirectory in cam_snapshot_src_mods in the CAM-SIMA backups repository.</p> <ul> <li>Make sure to revert those changes before running your final CAM regression tests!!!</li> </ul> </li> <li> <p>If you run into a \"tip\" that should be added here, please confer with the other CAM SEs to get it added to the documentation!!</p> </li> </ul>"},{"location":"conversion/walkthrough/","title":"Walkthrough Example","text":"<p>GASP! Our favorite imaginary software engineer Bug E. Code has been tasked with CCPP-izing lunar_tides*!</p> <p>*Scheme doesn't do anything outside of WACCM; chosen because it won't be CCPP-ized for real any time soon (so you can see what the existing code looks like)</p> <p>Here's how Bug completes this assignment...</p>"},{"location":"conversion/walkthrough/#0-background-prep-work","title":"0 - Background &amp; prep work","text":"<ol> <li> <p>Bug updates the conversion spreadsheet with his new assignment.</p> <p></p> </li> <li> <p>Bug opens issues in ESCOMP/CAM and ESCOMP/atmospheric_physics</p> <p></p> <p></p> </li> <li> <p>He sets up his sandbox (with his preexisting forks) and copies the portable layer via the following commands:</p> </li> </ol> <pre><code>git clone -o bugsy9236 https://github.com/bugsy9236/CAM CAM\ncd CAM\ngit fetch --tags ESCOMP\ngit branch ccppize-lunar-tides ESCOMP/cam_development\ngit checkout ccppize-lunar-tides \ngit push -u bugsy9236 ccppize-lunar-tides\nbin/git-fleximod update\ncd ..\ngit clone -o bugsy9236 https://github.com/bugsy9236/CAM-SIMA CAM-SIMA\ncd CAM-SIMA\ngit remote add ESCOMP https://github.com/ESCOMP/CAM-SIMA\ngit fetch --tags ESCOMP\ngit branch ccppize-lunar-tides ESCOMP/development\ngit checkout ccppize-lunar-tides \ngit push -u bugsy9236 ccppize-lunar-tides\nbin/git-fleximod update\nmkdir src/physics/ncar_ccpp/schemes/lunar_tides\ncp ../CAM/src/physics/cam/lunar_tides.F90 src/physics/ncar_ccpp/schemes/lunar_tides/\ncd src/physics/ncar_ccpp\ngit remote add bugsy9236 https://github.com/bugsy9236/atmospheric_physics\ngit fetch bugsy9236\ngit checkout -b ccppize-lunar-tides\ngit push -u bugsy9236 ccppize-lunar-tides\n\n</code></pre>"},{"location":"conversion/walkthrough/#1-convert-the-portable-layer","title":"1 - Convert the portable layer","text":""},{"location":"conversion/walkthrough/#1a-change-routine-names","title":"1a - Change routine names","text":"<p>Bug notes that there are three routines in <code>lunar_tides.F90</code>:</p> <pre><code>public :: lunar_tides_readnl\npublic :: lunar_tides_init\npublic :: lunar_tides_tend\n</code></pre> <ol> <li>He ignores <code>lunar_tides_readnl</code> for now (just leaves it as is)</li> <li>He's pretty sure that <code>lunar_tides_init</code> is an init routine, but confirms this by checking where it is called in <code>physpkg.F90</code>. It is indeed called by <code>phys_init</code>, so he can comfortably keep the <code>lunar_tides_init</code> routine name as is. No action needed here yet.</li> <li>Bug determines that <code>lunar_tides_tend</code> is called in <code>tphysac</code> (called every timestep after the coupler), so he renames <code>lunar_tides_tend</code> to <code>lunar_tides_run</code> throughout the module and proceeds</li> </ol> <p>End result:</p> <pre><code>public :: lunar_tides_readnl\npublic :: lunar_tides_init\npublic :: lunar_tides_run\n</code></pre>"},{"location":"conversion/walkthrough/#1b-add-required-htmlinclude-lines","title":"1b - Add required <code>\\htmlinclude</code> lines","text":"<p>Bug adds the necessary two lines above both the <code>lunar_tides_init</code> and <code>lunar_tides_run</code> routines.</p> <pre><code>!&gt; \\section arg_table_lunar_tides_init Argument Table\n!! \\htmlinclude lunar_tides_init.html\n  subroutine lunar_tides_init()\n    use cam_history, only: addfld\n    use time_manager,only: timemgr_get_calendar_cf\n\n    if (apply_lunar_tides) then\n       if (timemgr_get_calendar_cf().ne.'gregorian') then\n          call endrun('lunar_tides_init: calendar must be gregorian')\n       endif\n       call addfld('UT_LUNAR', (/ 'lev' /), 'A','m/s2','Zonal wind tendency due to lunar tides')\n       call addfld('VT_LUNAR', (/ 'lev' /), 'A','m/s2','Meridional wind tendency due to lunar tides')\n    end if\n\n  end subroutine lunar_tides_init\n\n  !==========================================================================\n  !==========================================================================\n!&gt; \\section arg_table_lunar_tides_run Argument Table\n!! \\htmlinclude lunar_tides_run.html\n  subroutine lunar_tides_run( state, ptend )\n    use time_manager, only: get_curr_date, get_julday\n    use physconst,    only: pi, rearth\n    use ppgrid,       only: pver\n    use cam_history,  only: outfld\n\n    type(physics_state), intent(in) :: state\n    type(physics_ptend), intent(out):: ptend\n    ...\n</code></pre>"},{"location":"conversion/walkthrough/#1c-clean-up-dummy-argument-dimensions","title":"1c - Clean up dummy argument dimensions","text":"<p>Bug makes sure no input/output variables have named dimensions in their declaration inside the routines. In this case, there are no dimensioned variables in the argument lists. So hooray!</p>"},{"location":"conversion/walkthrough/#1d-use-kind_phys-instead-of-r8","title":"1d - Use kind_phys instead of r8","text":"<p>Bug changes the use statement</p> <pre><code>use shr_kind_mod,   only: r8=&gt;shr_kind_r8\n</code></pre> <p>to </p> <pre><code>use ccpp_kinds, only: kind_phys\n</code></pre> <p>And does a find-and-replace for <code>r8</code> with <code>kind_phys</code></p> <p><code>lunar_tides_run</code> change (old -&gt; new):</p> <pre><code>subroutine lunar_tides_run( state, ptend )\n    use time_manager, only: get_curr_date, get_julday\n    use physconst,    only: pi, rearth\n    use ppgrid,       only: pver\n    use cam_history,  only: outfld\n\n    type(physics_state), intent(in) :: state\n    type(physics_ptend), intent(out):: ptend\n\n    integer  :: tod,yr,mm,dd\n    real(r8) :: jd,nu,lt,lun_lt\n\n    integer :: i, k\n\n    real(r8), parameter :: deg2hrs = 1._r8/15._r8\n    real(r8), parameter :: rad2deg = 180._r8/pi\n    real(r8), parameter :: rad2hrs = rad2deg*deg2hrs\n    real(r8), parameter :: tod2hrs = 24._r8/86400._r8\n    real(r8), parameter :: hrs2rad = 1._r8/rad2hrs\n</code></pre> <pre><code>subroutine lunar_tides_run( state, ptend )\n    use time_manager, only: get_curr_date, get_julday\n    use physconst,    only: pi, rearth\n    use ppgrid,       only: pver\n    use cam_history,  only: outfld\n\n    type(physics_state), intent(in) :: state\n    type(physics_ptend), intent(out):: ptend\n\n    integer  :: tod,yr,mm,dd\n    real(kind_phys) :: jd,nu,lt,lun_lt\n\n    integer :: i, k\n\n    real(kind_phys), parameter :: deg2hrs = 1._kind_phys/15._kind_phys\n    real(kind_phys), parameter :: rad2deg = 180._kind_phys/pi\n    real(kind_phys), parameter :: rad2hrs = rad2deg*deg2hrs\n    real(kind_phys), parameter :: tod2hrs = 24._kind_phys/86400._kind_phys\n    real(kind_phys), parameter :: hrs2rad = 1._kind_phys/rad2hrs\n</code></pre>"},{"location":"conversion/walkthrough/#1e-remove-use-statements","title":"1e - Remove use statements","text":"<p>Bug removes the <code>use</code> statements (except for <code>addfld</code> and <code>outfld</code> calls) and adds the relevant variables to the calling list. He also comments out any use statements from cam_history as well as any addfld and outfld calls. He also moves the namelist variable to module-level (above the <code>CONTAINS</code> statement) and passes it in to the calling list for _init</p> <p>For <code>lunar_tides_init</code>:</p> <pre><code>subroutine lunar_tides_init()\n    use cam_history, only: addfld\n    use time_manager,only: timemgr_get_calendar_cf\n\n    if (apply_lunar_tides) then\n       if (timemgr_get_calendar_cf().ne.'gregorian') then\n          call endrun('lunar_tides_init: calendar must be gregorian')\n       endif\n       call addfld('UT_LUNAR', (/ 'lev' /), 'A','m/s2','Zonal wind tendency due to lunar tides')\n       call addfld('VT_LUNAR', (/ 'lev' /), 'A','m/s2','Meridional wind tendency due to lunar tides')\n    end if\n\n  end subroutine lunar_tides_init\n</code></pre> <pre><code>subroutine lunar_tides_init(calendar, apply_lunar_tides_in)\n    !use cam_history, only: addfld\n    character(len=32), intent(in) :: calendar\n    logical,           intent(in) :: apply_lunar_tides_in\n\n    apply_lunar_tides = apply_lunar_tides_in\n\n    if (apply_lunar_tides) then\n       if (calendar.ne.'gregorian') then\n          call endrun('lunar_tides_init: calendar must be gregorian')\n       endif\n       !call addfld('UT_LUNAR', (/ 'lev' /), 'A','m/s2','Zonal wind tendency due to lunar tides')\n       !call addfld('VT_LUNAR', (/ 'lev' /), 'A','m/s2','Meridional wind tendency due to lunar tides')\n    end if\n\n  end subroutine lunar_tides_init\n</code></pre> <p>For <code>lunar_tides_run</code>:</p> <pre><code>subroutine lunar_tides_run( state, ptend )\n    use time_manager, only: get_curr_date, get_julday\n    use physconst,    only: pi, rearth\n    use ppgrid,       only: pver\n    use cam_history,  only: outfld\n\n    type(physics_state), intent(in) :: state\n    type(physics_ptend), intent(out):: ptend\n</code></pre> <pre><code>subroutine lunar_tides_run(state, ptend, curr_date_yr, &amp;\n     curr_date_mm, curr_date_dd, curr_date_tod, julday, &amp;\n     pi, rearth, pver)\n    !use cam_history,  only: outfld\n\n    type(physics_state), intent(in) :: state\n    type(physics_ptend), intent(out):: ptend\n    integer,             intent(in) :: curr_date_yr\n    integer,             intent(in) :: curr_date_mm\n    integer,             intent(in) :: curr_date_dd\n    integer,             intent(in) :: curr_date_tod\n    real(kind_phys),     intent(in) :: julday\n    real(kind_phys),     intent(in) :: pi\n    real(kind_phys),     intent(in) :: rearth\n    integer,             intent(in) :: pver\n\n</code></pre>"},{"location":"conversion/walkthrough/#1f-add-error-variables","title":"1f - Add error variables","text":"<p>Bug adds the <code>errmsg</code> and <code>errflg</code> variables to the end of the calling list and initializes them.</p> <pre><code>subroutine lunar_tides_run(state, ptend, curr_date_yr, &amp;\n     curr_date_mm, curr_date_dd, curr_date_tod, julday, &amp;\n     pi, rearth, pver, errmsg, errflg)\n    !use cam_history,  only: outfld\n\n    type(physics_state), intent(in) :: state\n    type(physics_ptend), intent(out):: ptend\n    integer,             intent(in) :: curr_date_yr\n    integer,             intent(in) :: curr_date_mm\n    integer,             intent(in) :: curr_date_dd\n    integer,             intent(in) :: curr_date_tod\n    real(kind_phys),     intent(in) :: julday\n    real(kind_phys),     intent(in) :: pi\n    real(kind_phys),     intent(in) :: rearth\n    integer,             intent(in) :: pver\n    character(len=512),  intent(out):: errmsg\n    integer,             intent(out):: errflg\n\n    ...\n\n    errflg = 0\n    errmsg = ''\n</code></pre>"},{"location":"conversion/walkthrough/#1g-replace-state-and-ptend-variables-in-calling-list","title":"1g - Replace state and ptend variables in calling list","text":"<p><code>lunar_tides_run</code> includes both <code>state</code> and <code>ptend</code>! Bug starts with <code>state</code> and figures out which state variables are used in the routine</p> <ul> <li>He determines that the routine uses <code>state%lat</code>, <code>state%lon</code>, <code>state%ncols</code>, and <code>state%zm</code></li> <li>He passes each in individually and ends up with:</li> </ul> <pre><code>subroutine lunar_tides_run(ncols, lat, lon, zm, ptend, &amp;\n     curr_date_yr, curr_date_mm, curr_date_dd, curr_date_tod, &amp;\n     julday, pi, rearth, pver, errmsg, errflg)\n    !use cam_history,  only: outfld\n\n    integer,             intent(in) :: ncols\n    real(kind_phys),     intent(in) :: lat(:)\n    real(kind_phys),     intent(in) :: lon(:)\n    real(kind_phys),     intent(in) :: zm(:,:)\n    type(physics_ptend), intent(out):: ptend\n    integer,             intent(in) :: curr_date_yr\n    integer,             intent(in) :: curr_date_mm\n    integer,             intent(in) :: curr_date_dd\n    integer,             intent(in) :: curr_date_tod\n    real(kind_phys),     intent(in) :: julday\n    real(kind_phys),     intent(in) :: pi\n    real(kind_phys),     intent(in) :: rearth\n    integer,             intent(in) :: pver\n    character(len=512),  intent(out):: errmsg\n    integer,             intent(out):: errflg\n\n</code></pre> <p>Now he does the same with <code>ptend</code> (the routine uses <code>ptend%u</code> and <code>ptend%v</code>) and ends up with:</p> <pre><code>subroutine lunar_tides_run(ncols, lat, lon, zm, dudt, dvdt, &amp;\n     curr_date_yr, curr_date_mm, curr_date_dd, curr_date_tod, &amp;\n     julday, pi, rearth, pver, errmsg, errflg)\n    !use cam_history,  only: outfld\n\n    integer,             intent(in) :: ncols\n    real(kind_phys),     intent(in) :: lat(:)\n    real(kind_phys),     intent(in) :: lon(:)\n    real(kind_phys),     intent(in) :: zm(:,:)\n    real(kind_phys),     intent(out):: dudt(:,:)\n    real(kind_phys),     intent(out):: dvdt(:,;)\n    integer,             intent(in) :: curr_date_yr\n    integer,             intent(in) :: curr_date_mm\n    integer,             intent(in) :: curr_date_dd\n    integer,             intent(in) :: curr_date_tod\n    real(kind_phys),     intent(in) :: julday\n    real(kind_phys),     intent(in) :: pi\n    real(kind_phys),     intent(in) :: rearth\n    integer,             intent(in) :: pver\n    character(len=512),  intent(out):: errmsg\n    integer,             intent(out):: errflg\n</code></pre> <p>As part of removing <code>ptend</code>, Bug removes the call to <code>physics_ptend_init</code> in <code>lunar_tides_run</code></p> <p>Replacing all the relevant variables in the routine results in...</p> <pre><code>subroutine lunar_tides_run(ncols, lat, lon, zm, dudt, dvdt, &amp;\n     curr_date_yr, curr_date_mm, curr_date_dd, curr_date_tod, &amp;\n     julday, pi, rearth, pver, errmsg, errflg)\n    !use cam_history,  only: outfld\n\n    integer,             intent(in) :: ncols\n    real(kind_phys),     intent(in) :: lat(:)\n    real(kind_phys),     intent(in) :: lon(:)\n    real(kind_phys),     intent(in) :: zm(:,:)\n    real(kind_phys),     intent(out):: dudt(:,:)\n    real(kind_phys),     intent(out):: dvdt(:,;)\n    integer,             intent(in) :: curr_date_yr\n    integer,             intent(in) :: curr_date_mm\n    integer,             intent(in) :: curr_date_dd\n    integer,             intent(in) :: curr_date_tod\n    real(kind_phys),     intent(in) :: julday\n    real(kind_phys),     intent(in) :: pi\n    real(kind_phys),     intent(in) :: rearth\n    integer,             intent(in) :: pver\n    character(len=512),  intent(out):: errmsg\n    integer,             intent(out):: errflg\n\n    real(kind_phys) :: nu,lt,lun_lt\n\n    integer :: i, k\n\n    real(kind_phys), parameter :: deg2hrs = 1._kind_phys/15._kind_phys\n    real(kind_phys), parameter :: rad2deg = 180._kind_phys/pi\n    real(kind_phys), parameter :: rad2hrs = rad2deg*deg2hrs\n    real(kind_phys), parameter :: tod2hrs = 24._kind_phys/86400._kind_phys\n    real(kind_phys), parameter :: hrs2rad = 1._kind_phys/rad2hrs\n\n    if (apply_lunar_tides) then\n\n       ! calculation relies on time from noon on December 31, 1899, so\n       ! subtract 2415020, which corresponds to the Julian date for Dec. 31 1899.\n       julday = julday - 2415020._kind_phys\n       julday = julday / 36525._kind_phys ! convert to julian centuries\n\n       ! Calculate the lunar local time (nu) based on the the time\n       ! in Julian centuries using the formula given in Chapman and Lindzen (1970)\n       nu = -9.26009_kind_phys + 445267.12165_kind_phys*julday+0.00168_kind_phys*julday*julday !nu in degrees\n\n       do i=1,ncol\n          ! solar local time (hours)\n          lt = real(curr_tod,kind=kind_phys)*tod2hrs + lon(i)*rad2hrs\n\n          ! lunar local time\n          lun_lt = lt - nu*deg2hrs ! hours\n          lun_lt = lun_lt*hrs2rad ! radians\n\n          do k=1,pver\n             ! Calculate the M2 lunar tide forcing in the zonal and meridional directions.\n             ! The forcing is calculated based on the gradient of the M2 tidal\n             ! potential, which is given in Chapman and Lindzen (1970).\n             ! Additional details on the derivation of the forcing are in\n             ! Pedatella, Liu, and Richmond (2012)\n             dudt(i,k) = (-1._kind_phys/((zm(i,k)+rearth)*cos(lat(i))))*2.456_kind_phys*3._kind_phys *  &amp;\n                  ((zm(i,k)+rearth)/rearth)**2*cos(lat(i))*cos(lat(i))*2._kind_phys*sin(2._kind_phys*lun_lt)\n             dvdt(i,k) = (1._kind_phys/(zm(i,k)+rearth))*2.456_kind_phys*3._kind_phys * &amp;\n                  ((zm(i,k)+rearth)/rearth)**2*cos(2._kind_phys*lun_lt)*2._kind_phys*cos(lat(i))*sin(lat(i))\n          end do\n       end do\n\n       !call outfld('UT_LUNAR', ptend%u(:state%ncol,:), state%ncol, state%lchnk)\n       !call outfld('VT_LUNAR', ptend%v(:state%ncol,:), state%ncol, state%lchnk)\n\n    end if\n\n  end subroutine lunar_tides_run\n\n</code></pre>"},{"location":"conversion/walkthrough/#1h-remove-pbuf-variables","title":"1h - Remove pbuf variables","text":"<p>Bug discovers that there are no <code>pbuf</code> variables in lunar_tides! Yay!</p>"},{"location":"conversion/walkthrough/#1i-mark-variables-as-initialized","title":"1i - Mark variables as initialized","text":"<p>There are no variables that Bug needs to mark as initialized. At least, so he thinks. He may revisit this!</p>"},{"location":"conversion/walkthrough/#1j-initial-standard-name-check","title":"1j - Initial standard name check","text":"<p>Bug does an initial check of the standard names spreadsheet. He is able to find standard names for all of the variables except the calendar type, current date and julian date info. He adds those to the spreadsheet and sends an email to the other CAM SEs about needing to decide on a standard name for these variables.</p>"},{"location":"conversion/walkthrough/#1k-update-cam-interface-calls","title":"1k - Update CAM interface call(s)","text":"<p>Bug updates the call in <code>physpkg.F90</code>:</p> <ul> <li>He renames the subroutine <code>lunar_tides_run</code></li> <li>He moves the use statements that he removed from <code>lunar_tides_run</code> to <code>tphysac</code> and adds calls to <code>get_curr_date</code> and <code>get_julday</code> to just before the call to <code>lunar_tides_run</code>. He passes in all the new variables.</li> <li>He moves the use statement that he removed from <code>lunar_tides_init</code> to <code>phys_init</code>, adds a call, and passes the <code>calendar</code> variable into <code>lunar_tides_init</code></li> </ul>"},{"location":"conversion/walkthrough/#1l-optional-make-a-cam-tag","title":"1l - OPTIONAL: Make a CAM tag","text":"<p>Bug opts not to make a CAM tag at this time.</p>"},{"location":"conversion/walkthrough/#2-create-snapshots-of-cam","title":"2 - Create snapshots of CAM","text":"<p>Bug discovers that there are no snapshot calls around <code>lunar_tides_run</code> in <code>physpkg.F90</code>. So he uses <code>user_set</code> snapshot calls as such:</p> <pre><code>! Lunar tides\n    if (trim(cam_take_snapshot_before) == \"user_set\") then\n       call cam_snapshot_all_outfld_tphysac(cam_snapshot_before_num, state, tend, cam_in, cam_out, pbuf, &amp;\n       flx_heat, cmfmc, cmfcme, zdu, rliq, rice, dlf, dlf2, rliq2, det_s, det_ice, net_flx)\n    end if\n    call lunar_tides_tend( state, ptend )\n    if ( (trim(cam_take_snapshot_after) == \"user_set\") .and.      &amp;\n         (trim(cam_take_snapshot_before) == trim(cam_take_snapshot_after))) then\n       call cam_snapshot_ptend_outfld(ptend, lchnk)\n    end if\n    if ( ptend%lu ) then\n      call outfld( 'UTEND_LUNART', ptend%u, pcols, lchnk)\n    end if\n    if ( ptend%lv ) then\n      call outfld( 'VTEND_LUNART', ptend%v, pcols, lchnk)\n    end if\n    call physics_update(state, ptend, ztodt, tend)\n    if (trim(cam_take_snapshot_after) == \"user_set\") then\n       call cam_snapshot_all_outfld_tphysac(cam_snapshot_after_num, state, tend, cam_in, cam_out, pbuf, &amp;\n       flx_heat, cmfmc, cmfcme, zdu, rliq, rice, dlf, dlf2, rliq2, det_s, det_ice, net_flx)\n    end if\n</code></pre> <p>Our main man Bug creates a test case with resolution <code>ne3pg3_ne3pg3_mg37</code> with DEBUG=True and the following <code>user_nl_cam</code>:</p> <pre><code>apply_lunar_tides = .true.\ncam_snapshot_before_num=6\ncam_snapshot_after_num=7\ncam_take_snapshot_before='user_set'\ncam_take_snapshot_after='user_set'\nnhtfrq = 0,0,0,0,0,1,1\nndens = 2,2,2,2,2,1,1\n</code></pre> <p>and runs the model for 7 timesteps. He saves the snapshot files in <code>/glade/campaign/cesm/community/amwg/sima_baselines/cam_sima_test_snapshots</code> with the names <code>cam_ne3pg3_lunar_tides_snapshot_derecho_gnu_before_c20240801.nc</code> and <code>cam_ne3pg3_lunar_tides_snapshot_derecho_gnu_after_c20240801.nc</code></p>"},{"location":"conversion/walkthrough/#3-create-metadata-file","title":"3 - Create metadata file","text":"<p>To generate his metadata file, Bug runs:</p> <pre><code>python ../../../../ccpp_framework/scripts/ccpp_fortran_to_metadata.py lunar_tides.F90\n</code></pre> <p>He then populates the generated metadata template (<code>lunar_tides.meta</code>) with the standard names, dimensions, and units. He ends up with:</p> <pre><code>[ccpp-table-properties]\n  name = lunar_tides\n  type = scheme\n\n[ccpp-arg-table]\n  name  = lunar_tides_init\n  type  = scheme\n[ calendar ]\n  standard_name = enter_standard_name_1\n  units = none\n  type = character | kind = len=32\n  dimensions = ()\n  intent = in\n[ apply_lunar_tides_in ]\n  standard_name = do_apply_lunar_tides\n  units = none\n  type = logical\n  dimensions = ()\n  intent = in\n[ errmsg ]\n  standard_name = ccpp_error_message\n  units = none\n  type = character | kind = len=512\n  dimensions = ()\n  intent = out\n[ errflg ]\n  standard_name = ccpp_error_code\n  units = 1\n  type = integer\n  dimensions = ()\n  intent = out\n\n[ccpp-arg-table]\n  name  = lunar_tides_run\n  type  = scheme\n[ ncols ]\n  standard_name = horizontal_loop_extent\n  units = count\n  type = integer\n  dimensions = ()\n  intent = in\n[ lat ]\n  standard_name = latitude\n  units = degree_north\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent)\n  intent = in\n[ lon ]\n  standard_name = longitude\n  units = degree_east\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent)\n  intent = in\n[ zm ]\n  standard_name = geopotential_height_wrt_surface\n  units = m\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent, vertical_layer_dimension)\n  intent = in\n[ dudt ]\n  standard_name = tendency_of_eastward_wind\n  units = m s-2\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent, vertical_layer_dimension)\n  intent = out\n[ dvdt ]\n  standard_name = tendency_of_northward_wind\n  units = m s-2\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent, vertical_layer_dimension)\n  intent = out\n[ curr_date_yr ]\n  standard_name = enter_standard_name_9\n  units = count\n  type = integer\n  dimensions = ()\n  intent = in\n[ curr_date_mm ]\n  standard_name = enter_standard_name_10\n  units = count\n  type = integer\n  dimensions = ()\n  intent = in\n[ curr_date_dd ]\n  standard_name = enter_standard_name_11\n  units = count\n  type = integer\n  dimensions = ()\n  intent = in\n[ curr_date_tod ]\n  standard_name = enter_standard_name_12\n  units = count\n  type = integer\n  dimensions = ()\n  intent = in\n[ julday ]\n  standard_name = enter_standard_name_13\n  units = none\n  type = real | kind = kind_phys\n  dimensions = ()\n  intent = in\n[ pi ]\n  standard_iname = pi_constant\n  units = 1\n  type = real | kind = kind_phys\n  dimensions = ()\n  intent = in\n[ rearth ]\n  standard_name = radius_of_earth\n  units = m\n  type = real | kind = kind_phys\n  dimensions = ()\n  intent = in\n[ pver ]\n  standard_name = vertical_layer_dimension\n  units = count\n  type = integer\n  dimensions = ()\n  intent = in\n[ errmsg ]\n  standard_name = ccpp_error_message\n  units = none\n  type = character | kind = len=512\n  dimensions = ()\n  intent = out\n[ errflg ]\n  standard_name = ccpp_error_code\n  units = 1\n  type = integer\n  dimensions = ()\n  intent = out\n</code></pre> <p>Bug will revisit the missing standard names when he hears back from the other CAM SEs/scientists about what the names should be.</p>"},{"location":"conversion/walkthrough/#4-create-namelist-xml-file","title":"4 - Create namelist XML file","text":"<p>Bug creates the following namelist xml file (called <code>lunar_tides_namelist.xml</code>) in the <code>ncar_ccpp/schemes/lunar_tides</code> directory. It contains one entry - for <code>apply_lunar_tides</code></p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n\n&lt;?xml-stylesheet type=\"text/xsl\"?&gt;\n\n&lt;entry_id_pg version=\"2.0\"&gt;\n  &lt;entry id=\"apply_lunar_tides\"&gt;\n    &lt;type&gt;logical&lt;/type&gt;\n    &lt;category&gt;waccm_phys&lt;/category&gt;\n    &lt;group&gt;lunar_tides_opts&lt;/group&gt;\n    &lt;standard_name&gt;control_for_lunar_tides&lt;/standard_name&gt;\n    &lt;units&gt;none&lt;/units&gt;\n    &lt;valid_values&gt;&lt;/valid_values&gt;\n    &lt;desc&gt;\n      Switch to apply lunar tidal tendencies to neutral winds. Default: FALSE\n    &lt;/desc&gt;\n    &lt;values&gt;\n      &lt;value&gt;.false.&lt;/value&gt;\n    &lt;/values&gt;\n  &lt;/entry&gt;\n&lt;/entry_id_pg&gt;\n\n</code></pre> <p>He then removes <code>lunar_tides_readnl</code> from <code>lunar_tides.F90</code>. This routine and it's metadata will be auto-generated by CAM-SIMA.</p>"},{"location":"conversion/walkthrough/#5-interstitials","title":"5 - Interstitials","text":"<p>Bug determines that he does not need any interstitials. The only candidates were calculations of the current time and julian year, but, after consulting with other CAM SEs, it was determined that CAM-SIMA will be updated to provide these values.</p>"},{"location":"conversion/walkthrough/#6-create-an-sdf","title":"6 - Create an SDF","text":"<p>Bug creates the following Suite Definition File (including state updaters):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;suite name=\"lunar_tides\" version=\"1.0\"&gt;\n   &lt;group name=\"physics_after_coupler\"&gt;\n       &lt;scheme&gt;lunar_tides&lt;/scheme&gt;\n       &lt;scheme&gt;apply_tendency_of_eastward_wind&lt;/scheme&gt;\n       &lt;scheme&gt;apply_tendency_of_northward_wind&lt;/scheme&gt;\n   &lt;/group&gt;\n&lt;/suite&gt;\n</code></pre>"},{"location":"conversion/walkthrough/#7-check-metadata","title":"7 - Check metadata","text":"<p>Once he hears back about the missing standard names and populates them in the metadata, Bug creates a new case and runs <code>./preview_namelists</code>.</p> <p>He runs into the following error:</p> <pre><code>Input argument for lunar_tides_init, calendar_type, not found.\n</code></pre> <p>This is one of the new standard names, but it isn't something read in from a file. He'll need to add it to the registry and then initialize the variable within CAM-SIMA. He adds this entry to the registry (<code>src/data/registry.xml</code>):</p> <pre><code>&lt;variable local_name=\"calendar_type\"\n          standard_name=\"calendar_type\"\n          units=\"none\" type=\"character\" kind=\"len=32\"&gt;\n  &lt;long_name&gt;calendar type&lt;/long_name&gt;\n&lt;/variable&gt;\n</code></pre> <p>Then, in <code>cam_comp.F90</code>, he adds these use statements to the top of the module:</p> <pre><code>use time_manager, only: timemgr_get_calendar_cf\nuse physics_types, only: calendar_type\nuse phys_vars_init_check, only: mark_as_initialized\n</code></pre> <p>Then adds these calls after the call to <code>timemgr_init</code>:</p> <pre><code>calendar_type = timemgr_get_calendar_cf()\ncall mark_as_initialized('calendar_type')\n</code></pre> <p>Bug then works through any remaining errors until the <code>preview_namelists</code> command completes.</p>"},{"location":"conversion/walkthrough/#8-run-cam-sima","title":"8 - Run CAM-SIMA","text":"<p>Bug builds and runs the model with <code>user_nl_cam</code> pointing to the before/after snapshots.</p> <pre><code>ncdata = '/glade/campaign/cesm/community/amwg/sima_baselines/cam_sima_test_snapshots/cam_ne3pg3_lunar_tides_snapshot_derecho_gnu_before_c20240801.nc'\nncdata_check = '/glade/campaign/cesm/community/amwg/sima_baselines/cam_sima_test_snapshots/cam_ne3pg3_lunar_tides_snapshot_derecho_gnu_after_c20240801.nc'\n</code></pre> <p>Bug gets extremely lucky (or maybe he's just really skilled) and there are no differences found in the atm.log file!</p>"},{"location":"conversion/walkthrough/#9-bring-back-into-cam","title":"9 - Bring back into CAM","text":"<ol> <li>Bug moves the CCPP-ized version of lunar_tides.F90 into the CAM source tree by checking out his branch's hash of the atmospheric_physics branch (NOTE: this will need to be a tag before the PR to CAM can be brought in). </li> <li>He renames the old <code>src/physics/cam/lunar_tides.F90</code> file to <code>src/physics/cam/lunar_tides_cam.F90</code><ul> <li>He removes everything from <code>lunar_tides_cam.F90</code> except <code>lunar_tides_readnl</code></li> </ul> </li> <li>Bug updates the <code>lunar_tides_init</code> and <code>lunar_tides_tend</code> subroutine calls in <code>physpkg.F90</code> to reflect the new CCPP-ized versions (full calling list, changing <code>lunar_tides_tend</code> to <code>lunar_tides_run</code>)</li> <li>Bug updates <code>configure</code>, and runs CAM. He confirms that it runs and answers haven't changed.</li> </ol> <p>Bug commits his changes to his fork/branch of the three repos: CAM, CAM-SIMA, atmospheric_physics.</p>"},{"location":"conversion/walkthrough/#10-final-steps","title":"10 - Final steps","text":"<ul> <li>He opens a PR into atmospheric_physics (target: <code>development</code> branch), goes through the review process, updates the NamesNotInDictionary.txt file, and then commits the PR when approvals are received. He then opens a PR from <code>development</code> to <code>main</code> and makes a tag (incrementing the minor version) when that is merged.</li> <li>Once he has a tag, he opens PRs into CAM (target: <code>cam_development</code> branch) and CAM-SIMA (target: <code>development</code> branch) with the updated tag in <code>.gitmodules</code> (and code changes needed, including adding a new snapshot regression test in CAM-SIMA). When approvals are in and he gets the go-ahead to make a tag, he follows the procedures to make a CAM or CAM-SIMA tag.</li> <li>Once all tags are made, he checks off \"lunar tides\" as completed in the spreadsheet.</li> </ul> <p>A single tear of joy navigates its way down Bug's weathered face. He has prevailed. He solemnly closes his computer and walks off, disappearing into the horizon.</p>"},{"location":"design/cam-build-process/","title":"Build process","text":"<p>In order to describe the build process, we need to define several source and build directories:</p> <ul> <li><code>&lt;srcroot&gt;</code> : The CAM-SIMA sandbox being built. From a case directory, this can be found with <code>./xmlquery SRCROOT.</code></li> <li><code>&lt;caseroot&gt;</code>: The location of the case being built.</li> <li><code>&lt;src_mods&gt;</code>: The location of the CAM-SIMA source mods, located at <code>&lt;caseroot&gt;/SourceMods/src.cam.</code></li> <li><code>&lt;bldroot&gt;</code> : The location of CAM-SIMA generated code and compiled code (<code>.o</code> and <code>.mod</code>). See <code>atm/obj</code> under <code>./xmlquery OBJROOT</code>.</li> </ul>"},{"location":"design/cam-build-process/#build-sequence","title":"Build Sequence","text":"<p>Given the context above, the following is the CAM-SIMA build sequence:</p> <ol> <li>Create a <code>ConfigCAM</code> object, used to store build configuration information. Code can be found in <code>&lt;srcroot&gt;/cime_config/cam_config.py</code><ul> <li>Inputs:<ul> <li><code>&lt;case&gt;</code>: A CIME case object</li> <li><code>&lt;case_log&gt;</code>: A python logger, which is usually created by CIME itself</li> </ul> </li> <li>Outputs:<ul> <li><code>config_dict</code>: A dictionary of configure options, with the dictionary keys being the name of the config variable/option, and the dictionary values being special config variable objects that contain the following properties:<ul> <li><code>name</code>: The name of the config option/variable. This is what is used as the key in the <code>config_dict</code> dictionary</li> <li><code>desc</code>: A text description of what this particular config option is, and what sort of values the config option should have.</li> <li><code>value</code>: The value of that config option/variable. Currently can only be an integer, string, or list of integers or strings.</li> <li><code>valid_vals</code>: Optional property that contains either a list or range of valid values for this particular config entry</li> <li><code>valid_type</code>: Optional property for a list-type config option that states what data type the list elements can have.</li> <li><code>is_nml_attr</code>: Logical that states whether this config option can be used as an XML attribute in a namelist definition file.</li> </ul> </li> </ul> </li> <li>Additional info:<ul> <li>The <code>ConfigCAM</code> object also has various build-in methods that are used to call other steps in the build workflow, change the value of a given config variable, or print extra config info to the provided python logger.</li> <li>The <code>ConfigCAM</code> object currently has no uses outside <code>buildnml</code> and <code>buildlib</code>, and so is not saved after those steps are complete.</li> </ul> </li> </ul> </li> <li>Generate CAM-SIMA source code. This sequence has several steps, each of which is performed if any of its inputs has changed.<ul> <li>Create or read in a <code>BuildCacheCAM</code> object (<code>&lt;srcroot&gt;/cime_config/cam_build_cache.py</code>).<ul> <li><code>&lt;build_cache&gt;</code>: An optional cache file (created by previous build). This file is created in the case build directory (bld/atm/obj).</li> </ul> </li> <li>Create the physics derived data types using the registry (if required).</li> <li>Find all scheme metadata files for configured suites.</li> <li>Find any active schemes with namelist XML variables<ul> <li>Create metadata file with namelist variables</li> <li>Create namelist-reading module (to go with metadata file).</li> </ul> </li> <li>Call the CCPP Framework to generate glue code (CAPS), (if required).</li> </ul> </li> </ol>"},{"location":"design/cam-build-process/#cam-sima-source-and-namelist-generation-buildnml-workflow","title":"CAM-SIMA source and namelist generation (buildnml) workflow","text":"<p>The diagram above displays everything that occurs when CAM-SIMA's <code>buildnml</code> is called by CIME, which occurs after the user calls <code>preview_namelists</code>, <code>case.build</code>, or <code>case.submit</code>.</p> <p>All blue boxes represent source code, and are listed as \"source file: function/object used\", and all objects or functions that have a \"+\" are automatically tested whenever a Pull Request is opened, updated, or merged.</p> <p>All orange boxes are input files that are used by the code, while all green boxes are output files that are generated. It is important to note that additional files are generated as well, specifically a build cache and a CCPP datatable, but those files are used internally in the build scripts shown here and not by the final model executable, and thus aren't listed here.</p> <p>Finally, the arrows show the order of operations, starting with <code>buildnml</code>, with the top two source code boxes representing python classes that are used by the functions/objects directly below them.</p>"},{"location":"design/cam-run-process/","title":"Run process","text":"CAM-SIMA run sequence* <p>*Static images can be found at the bottom of this page</p>"},{"location":"design/cam-run-process/#cam-sima-api","title":"CAM-SIMA API","text":"<p>Upon running <code>./case.submit</code> the core CAM-SIMA driver code* is in <code>$CAM-SIMA/src/control/cam_comp.F90</code>. This section lays out each of the subroutines within <code>cam_comp.F90</code>. The subroutines in <code>cam_comp.F90</code> are set up to mirror the phases of the Common Community Physics Package (CCPP).</p> <p>* <code>cam_comp.F90</code> subroutines are called by the NUOPC cap: <code>$CAM-SIMA/src/cpl/nuopc/atm_comp_nuopc.F90</code></p>"},{"location":"design/cam-run-process/#cam_init","title":"cam_init","text":"<p><code>cam_init</code> sets up the metadata and configuration objects/modules for the run. It is called once at startup. Below are the variables passed in:</p> Variable (intent) Definition How it's Used caseid (in) case name (as input to ./create_newcase) metadata for cam_control_mod and cam_history ctitle (in) case title (matches caseid) metadata for cam_control_mod and cam_history model_doi_url (in) CESM model DOI (currently hard-coded to \"non_set\") metadata for cam_history initial_run_in (in) logical that is TRUE if this is a startup run** determines whether to call dyn_init or read restart restart_run_in (in) logical that is TRUE if this is a restart run** metadata for cam_control_mod branch_run_in (in) logical that is TRUE if this is a branch run** metadata for cam_control_mod post_assim_in (in) logical that is TRUE if data assimilation mode (DART) is on metadata for cam_control_mod calendar (in) calendar type (NOLEAP or GREGORIAN) input to time manager init brnch_retain_casename (in) flag to allow a branch to use the same caseid as the run being branched from metadata for cam_control_mod aqua_planet (in) flag to run model in aqua planet mode metadata for cam_control_mod single_column (in) flag to run the single column model (SCAM) passed into scam_readnl (not yet enabled in CAM-SIMA scmlat (in) SCAM latitude passed into scam_readnl (not yet enabled in CAM-SIMA) scmlon (in) SCAM longitude passed into scam_readnl (not yet enabled in CAM-SIMA) eccen (in) Earth's eccentricity factor used to set module-level <code>eccen</code> in cam_control_mod obliqr (in) Earth's obliquity in radians used to set module-level <code>obliqr</code> in cam_control_mod lambm0 (in) Mean longitude of perihelion at the vernal equinox (radians) used to set module-level <code>lambm0</code> in cam_control_mod mvelpp (in) Earth's moving vernal equinox longitude of perihelion plus pi (radians) used to set module-level <code>mvelpp</code> in cam_control_mod perpetual_run (in) flag to determine if perpetual mode is enabled passed to time manager init perpetual_ymd (in) perpetual year, month, day (YYYYMMDD) used to determine the sun position and interpolate boundary data sets passed to time manager init dtime (in) model timestep size in seconds passed to time manager init start_ymd (in) start date (YYYYMMDD) passed to time manager init start_tod (in) start time of day (sec) passed to time manager init ref_ymd (in) reference date (YYYYMMDD) (defaults to start_ymd) passed to time manager init ref_tod (in) reference time of day (sec) (defaults to start_tod) passed to time manager init stop_ymd (in) stop date (YYYYMMDD) passed to time manager init stop_tod (in) stop time of day (sec) passed to time manager init curr_ymd (in) current date (YYYYMMDD) (same as start date) passed to time manager init curr_tod (in) current time of day (sec) (same as start tod) passed to time manager init cam_in (inout) surface exchange object - coupler to CAM-SIMA allocated if this is an initial run cam_out (inout) surface exchange object - CAM-SIMA to coupler allocated if this is an initial run <p>** For additional information on run types, see the CESM Tutorial</p> <p><code>cam_init</code> calls the following key subroutines (locations) in this order:</p> <ol> <li><code>cam_ctrl_init</code> (<code>src/control/cam_control_mod.F90</code>): Sets the module-level run configuration variables; logs configurations to the atm log</li> <li><code>cam_ctrl_set_orbit</code> (<code>src/control/cam_control_mod.F90</code>): Sets the module-level orbital variables</li> <li><code>timemgr_init (</code>src/utils/time_manager.F90`): Initializes the time manager; logs configurations to the atm log</li> <li><code>read_namelist</code> (<code>src/control/runtime_opts.F90</code>): Reads all namelists for the run, including auto-generated scheme namelists (see build process)</li> <li><code>cam_ctrl_set_physics_type</code> (<code>src/control/cam_control_mod.F90</code>): sets module-level configuration for variables for simple physics and moist physics schemes; logs configurations to atm log</li> <li><code>cam_initfiles_open</code> (<code>src/control/cam_initfiles.F90</code>): Opens initial or restart file, and topography file if specified</li> <li><code>phys_register</code> (<code>src/physics/utils/phys_comp.F90</code>): Registers physics (includes call to CCPP cap to run register phases of schemes in the Suite Definition File (SDF))</li> <li><code>cam_register_constituents</code> (<code>src/control/cam_comp.F90</code>): Sets the total number and advected number of constituents; currently ALWAYS adds water vapor as constituent (expected by the SE dycore)</li> <li><code>air_composition_init</code> (<code>src/data/air_composition.F90</code>): Initializes air-composition-dependent model constants</li> <li><code>model_grid_init</code> (<code>src/dynamics/&lt;dycore&gt;/dyn_grid.F90</code>): Initializes model grids and decompositions</li> <li><code>cam_ccpp_initialize_constituents</code> (<code>$CASE/bld/atm/obj/ccpp/cam_ccpp_cap.F90</code>): initializes the constituent data array; after this point, we cannot add new constituents</li> <li><code>dyn_init</code> (<code>src/dynamics/&lt;dycore&gt;/dyn_comp.F90</code>): Initializes the dynamical core</li> <li><code>atm2hub_alloc</code> and <code>hub2atm_alloc</code> (<code>src/control/camsrfexch.F90</code>): Allocates and sets up surface exchange data</li> <li><code>phys_init</code> (<code>src/physics/utils/phys_comp.F90</code>): Initializes physics (includes call to CCPP cap to run init phases of schemes in the Suite Definition File (SDF))</li> <li><code>stepon_init</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): Initializes dynamics &lt;--&gt; physics coupling</li> </ol>"},{"location":"design/cam-run-process/#cam_timestep_init","title":"cam_timestep_init","text":"<p><code>cam_timestep_init</code> is called at the start of each timestep. It has no input/output/inout variables.</p> <p>The routine calls the following subroutines (locations) in this order:</p> <ol> <li><code>stepon_timestep_init</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): First phase of dynamics (couple from dynamics to physics); also returns timestep for physics</li> <li><code>phys_timestep_init</code> (<code>src/physics/utils/phys_comp.F90</code>):<ol> <li>Read un-initialized data from initial data file<ul> <li>For the null dycore, this means we're reading most physics input variables (as defined in <code>src/data/registry.xml</code>) from the ncdata file</li> <li>For the SE dycore, we are reading in any variables not marked as initialized by the SE dycore initialization</li> </ul> </li> <li>Calls the CCPP cap to run timestep_init phases of all schemes in the user-specified SDF</li> </ol> </li> </ol>"},{"location":"design/cam-run-process/#cam_run1","title":"cam_run1","text":"<p><code>cam_run1</code> is the first \"run\" phase called in the physics loop. It is called every timestep BEFORE the mediator/surface coupler and calls the following subroutine (location):</p> <ol> <li><code>phys_run1</code> (<code>src/physics/utils/phys_comp.F90</code>): Calls the run phase for all physics schemes in the \"physics_before_coupler\" group in the SDF</li> </ol>"},{"location":"design/cam-run-process/#cam_run2","title":"cam_run2","text":"<p><code>cam_run2</code> is the second \"run\" phase called in the physics loop. It is called every timestep AFTER the mediator/coupler. Input/output variables:</p> Variable (intent) Definition How it's Used cam_in (inout) surface exchange object - input to CAM-SIMA Passed into stepon_run2 cam_out (inout) surface exchange object - output from CAM-SIMA Passed into stepon_run2 <p><code>cam_run2</code> calls these subroutines (locations):</p> <ol> <li><code>phys_run2</code> (<code>src/physics/utils/phys_comp.F90</code>): Calls the run phase for all physics schemes in the \"physics_after_coupler\" group in the SDF</li> <li><code>stepon_run2</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): The second phase of dynamics (couple from physics to dynamics)</li> </ol>"},{"location":"design/cam-run-process/#cam_run3","title":"cam_run3","text":"<p><code>cam_run3</code> is the third \"run\" phase called in the physics loop. It is called every timestep AFTER cam_run3 and BEFORE cam_run4 (unsurprisingly). In/out variables:</p> Variable (intent) Definition How it's Used cam_out (inout) surface exchange object - output from CAM-SIMA Passed into stepon_run3 <p><code>cam_run3</code> calls the following subroutine (location):</p> <ol> <li><code>stepon_run3</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): Calls <code>dyn_run</code>, which runs the dycore</li> </ol>"},{"location":"design/cam-run-process/#cam_run4","title":"cam_run4","text":"<p><code>cam_run4</code> currently does nothing! (but it is called every timestep)</p>"},{"location":"design/cam-run-process/#cam_timestep_final","title":"cam_timestep_final","text":"<p><code>cam_timestep_final</code> runs at the end of each timestep. In/out variables:</p> Variable (intent) Definition How it's Used rstwr (in) flag to write a restart file Passed into history_wrap_up nlend (in) flag to indicate whether this is the final timestep Passed into history_wrap_up <p><code>cam_timestep_final</code> calls the following subroutines (locations):</p> <ol> <li>History routines. If it's not the last (half) timestep,<ol> <li><code>history_write_files</code> (<code>src/history/cam_history.F90</code>): Writes fields to user-configured history files (if applicable)</li> <li><code>history_wrap_up</code> (<code>src/history/cam_history.F90</code>): Closes files and zeros buffers as necessary</li> </ol> </li> <li><code>phys_timestep_final</code> (<code>src/physics/utils/phys_comp.F90</code>):<ol> <li>Calls the timestep_final phase for all physics schemes in the SDF</li> <li>If <code>ncdata_check</code> is set in <code>user_nl_cam</code>, calls <code>physics_check_data</code> (<code>$CASE/bld/atm/obj/phys_init/physics_inputs.F90</code>) to perform snapshot checking</li> </ol> </li> </ol>"},{"location":"design/cam-run-process/#cam_final","title":"cam_final","text":"<p><code>cam_final</code> is called once at the end of the model execution. In/out variables:</p> Variable (intent) Definition How it's Used cam_in (inout) surface exchange object - input to CAM-SIMA Deallocated cam_out (inout) surface exchange object - output from CAM-SIMA Deallocated <p><code>cam_final</code> calls the following subroutines (locations):</p> <ol> <li><code>phys_final</code> (<code>src/physics/utils/phys_comp.F90</code>): calls \"final\" phase of all schemes in the SDF</li> <li><code>stepon_final</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): finalizes dycore (doesn't currently do anything)</li> <li><code>atm2hub_deallocate</code> and <code>hub2atm_deallocate</code> (<code>src/control/camsrfexch.F90</code>): deallocate cam_in/cam_out objects</li> </ol>"},{"location":"design/cam-run-process/#static-run-sequence-images","title":"Static run sequence images","text":""},{"location":"design/ccpp-in-cam-sima/","title":"CCPP in CAM-SIMA","text":""},{"location":"design/ccpp-in-cam-sima/#overview","title":"Overview","text":"<p>The core Common Community Physics Package (CCPP) documentation can be found here. This section details the code structure and implementation of the CCPP Framework within CAM-SIMA. That said here's a quick overview of the CCPP:</p> <ul> <li>A CCPP-enabled model consists of the following components (depicted in the diagram below):<ul> <li>Host model and dynamical core</li> <li>CCPP-compliant physics schemes (organized into Suite Definition Files [SDFs])</li> <li>Caps generated by the CCPP framework to connect the host model to the physics schemes</li> </ul> </li> </ul> <p></p> <p>CCPP-compliant physics schemes must adhere to the following criteria:</p> <ul> <li>Must be broken up into only the following phases:<ul> <li>register (anything in the scheme that must be done before the grid is initialized) - run once at startup</li> <li>init - run once at startup</li> <li>timestep_init - run at beginning of every physics timestep</li> <li>run - run on every timestep</li> <li>timestep_final - run at the end of every timestep</li> <li>final - run once at the end of model execution</li> </ul> </li> <li>Must contain metadata for all input/output/inout variables passed into each phase (see metadata example below)</li> <li>Must not have use statements outside of the following allowed CCPP use statements (with the exception of <code>dependencies</code>, but we're not getting into that now):<ul> <li>ccpp_kinds</li> <li>ccpp_constituent_prop_mod</li> </ul> </li> </ul> <p>Metadata example (snippet taken from <code>kessler.meta</code>)</p> <pre><code>[ precl ]\n  standard_name = total_precipitation_rate_at_surface\n  long_name = Total precipitation rate at surface\n  units = m s-1\n  dimensions = (horizontal_loop_extent)\n  type = real | kind = kind_phys\n  intent = out\n[ relhum ]\n  standard_name = relative_humidity\n  long_name = Relative humidity\n  units = percent\n  dimensions = (horizontal_loop_extent, vertical_layer_dimension)\n  type = real | kind = kind_phys\n  intent = out\n[ scheme_name ]\n  standard_name = scheme_name\n  units = none\n  type = character | kind = len=64\n  dimensions = ()\n  intent = out\n\n</code></pre> <p>CCPP-compliant physics schemes are organized into suite definition files (SDFs). An SDF tells the framework which schemes will be run in what order. Separating schemes into \"groups\" also allows the run phases of those groups to be called separately by the host model. Here's an example SDF (from suite_kessler.xml):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;suite name=\"kessler\" version=\"1.0\"&gt;\n  &lt;group name=\"physics_before_coupler\"&gt;\n    &lt;scheme&gt;calc_exner&lt;/scheme&gt;\n    &lt;scheme&gt;temp_to_potential_temp&lt;/scheme&gt;\n    &lt;scheme&gt;calc_dry_air_ideal_gas_density&lt;/scheme&gt;\n    &lt;scheme&gt;wet_to_dry_water_vapor&lt;/scheme&gt;\n    &lt;scheme&gt;wet_to_dry_cloud_liquid_water&lt;/scheme&gt;\n    &lt;scheme&gt;wet_to_dry_rain&lt;/scheme&gt;\n    &lt;scheme&gt;kessler&lt;/scheme&gt;\n    &lt;scheme&gt;potential_temp_to_temp&lt;/scheme&gt;\n    &lt;scheme&gt;dry_to_wet_water_vapor&lt;/scheme&gt;\n    &lt;scheme&gt;dry_to_wet_cloud_liquid_water&lt;/scheme&gt;\n    &lt;scheme&gt;dry_to_wet_rain&lt;/scheme&gt;\n    &lt;scheme&gt;kessler_update&lt;/scheme&gt;\n    &lt;scheme&gt;qneg&lt;/scheme&gt;\n    &lt;scheme&gt;geopotential_temp&lt;/scheme&gt;\n    &lt;scheme&gt;cam_state_diagnostics&lt;/scheme&gt;\n    &lt;scheme&gt;kessler_diagnostics&lt;/scheme&gt;\n  &lt;/group&gt;\n  &lt;group name=\"physics_after_coupler\"&gt;\n    &lt;scheme&gt;cam_tend_diagnostics&lt;/scheme&gt;\n  &lt;/group&gt;\n&lt;/suite&gt;\n</code></pre> <p>The framework code is primarily python code that generates Fortran caps. The class structure looks like:</p> <p>Given CCPP-compliant physics schemes and one or more SDF, the framework generates caps for the host model to call at the appropriate time. The core files generated by the framework are:</p> <ul> <li><code>&lt;host&gt;_ccpp_cap.F90</code>: contains the interface layer between the host and the suite(s)</li> <li><code>ccpp_&lt;suite&gt;_cap.F90</code>: contains one subroutine per phase (including one run phase per group) in which the phases of the schemes within the suite are called in order<ul> <li>There is one suite cap generated for each suite being run</li> </ul> </li> <li><code>ccpp_datatable.xml</code>: consolidates metadata into an XML file to be used as desired by the host model</li> </ul>"},{"location":"design/ccpp-in-cam-sima/#code-structure","title":"Code Structure","text":"<p>How CAM-SIMA and the CCPP come together: </p>"},{"location":"design/ccpp-in-cam-sima/#host-model","title":"Host Model","text":"<p>The core host model code is what is held in the CAM-SIMA github repository, plus code that is generated at build-time (or preview_namelists-time) based on the registry (<code>src/data/registry.xml</code>).</p>"},{"location":"design/ccpp-in-cam-sima/#physics","title":"Physics","text":"<p>The CCPP physics scheme code exists in the atmospheric_physics repository, which exists as a submodule of CAM-SIMA in the following location: <code>$CAM-SIMA/src/physics/ncar_ccpp</code></p> <p>SDFs are located in the root directory of the repository and scheme source code is in the relevant subdirectories. </p> <p>The <code>diagnostics</code> directory contains all diagnostic schemes (the global ones used for state and tendency output, as well as the scheme-specific diagnostic schemes).</p> <p>The <code>to_be_ccppized</code> directory contains physics schemes and utilties that have not been CCPP-ized, but were needed by an CCPP-ized scheme.</p> <p>The <code>utilities</code> directory contains schemes that are used regularly, such as tendency applicators and state converters. See below for more.</p>"},{"location":"design/ccpp-in-cam-sima/#generated-caps","title":"Generated caps","text":"<p>The caps generated by the CCPP Framework at model build time (or preview_namelists-time) can be found in the following location: <code>$CASE/bld/atm/obj/ccpp/</code></p>"},{"location":"design/ccpp-in-cam-sima/#implementation","title":"Implementation","text":"<p>All CCPP phases are called from the physics driver (<code>src/physics/utils/phys_comp.F90</code>). You can see the order of these calls more thoroughly in the documented run sequence.</p>"},{"location":"design/ccpp-in-cam-sima/#host-side-variables-and-metadata","title":"Host-side variables and metadata","text":"<p>For a CCPP-ized physics scheme to work, the framework needs to be able to find a matching variable on the host side for each input variable for the suite(s) in question. This means that CAM-SIMA needs to allocate, initialize, and provide metadata for these variables. We do this in two ways:</p> <ul> <li>Adding metadata to existing CAM modules (such as <code>src/data/physconst.F90</code>) so that a scheme can access an existing host model variable<ul> <li>All static host-side metadata schemes are included at the top of the registry</li> </ul> </li> <li>Adding a variable to the registry (<code>src/data/registry.xml</code>)<ul> <li>You can learn more about how the registry is used to generate a Fortran module and corresponding metadata here</li> </ul> </li> </ul> <p>The registry-based code generator is run before the CCPP framework does its magic, so, when it's time, the framework can connect the dots between the host model and the physics.</p>"},{"location":"design/ccpp-in-cam-sima/#state-and-tendency-variables","title":"State and tendency variables","text":"<p>Two of the most commonly used and referred-to objects in CAM-SIMA are:</p> <ul> <li>physics_state</li> <li>physics_tend</li> </ul> <p>The Fortran for both objects is auto-generated by CAM-SIMA based on the registry (<code>$CAM-SIMA/src/data/registry.xml</code>). The generated code can be found here: <code>$CASE/bld/atm/obj/cam_registry/physics_types.F90</code>. The objects are used by the host model (CAM-SIMA), while the CCPP physics take the individual component variables as inputs.</p>"},{"location":"design/ccpp-in-cam-sima/#physics-state","title":"Physics state","text":"<p>The physics_state object in CAM-SIMA contains the current values for a select set of variables that describe the atmosphere, at the resolution specified by the input grid.</p> <p>Some examples of these core \"state\" variables include temperature (<code>T</code>), eastward wind (<code>U</code>), and northward wind (<code>V</code>)</p> <p>As a rule, CAM-SIMA physics schemes do not update the state directly and instead return tendencies (see below) which are then applied to the state later in the run phase. This is called time splitting, which means that all physics since the last state update get the same input state. The alternative, process splitting, means that the output state of one scheme serves as the input state of the next.</p> <p>NOTE: Although constituents are handled independently of the <code>physics_state</code> object (they are handled by the CCPP framework), they ARE considered state variables.</p>"},{"location":"design/ccpp-in-cam-sima/#physics-tendencies","title":"Physics tendencies","text":"<p>The physics tendencies represent how a given scheme (or schemes) changes the state in a single model timestep. The tendencies are accumulated until it is time to apply them to the state. There is one tendency for each state variable being \"updated\" by the scheme. Some of these tendency variables are held within the physics_tend object, but others are internal to the physics.</p> <p>The module <code>$CAM-SIMA/src/physics/ncar_ccpp/utilities/physics_tendency_updaters.F90</code> includes the schemes to apply the tendencies to the relevant state variables. These schemes are added to the SDF whenever the state should be updated. Each calculation looks like: <code>state_var = state_var + tend*dt</code> where <code>dt</code> is the timestep size.</p>"},{"location":"design/constituents/","title":"Constituents","text":""},{"location":"design/constituents/#introductionoverview","title":"Introduction/Overview","text":"<p>Some definitions to start (as written by a non-scientist, so there is more nuance than this!):</p> <ul> <li>A constituent is a physical quantity or substance that exists in the atmosphere</li> <li>A constituent can be advected, which means it is moved through the atmosphere by some sort of dynamical method<ul> <li>The dynamical core (dycore) is the part of an atmosphere model (like CAM-SIMA) that advects the quantities over the underlying grid. Dynamical cores include:<ul> <li>null/none - the null dycore does nothing and is used in CAM-SIMA to validate physics schemes</li> <li>spectral element (SE): the only dycore currently implemented in CAM-SIMA</li> <li>finite-volume cubed-sphere (FV3): not currently implemented in CAM-SIMA</li> <li>model for prediction across scales (MPAS): in progress</li> </ul> </li> </ul> </li> <li>A constituent had additional properties, such as:<ul> <li>water type: can be \"dry\", \"wet\", or \"moist\" (we can convert between any of these quantities - \"dry\" means that it's the \"amount\" of that constituent with respect to dry air</li> <li>mixing ratio type: can be \"volume\" or \"mass\"<ul> <li>volume mixing ratio: constituent values are a ratio of how much of the constituent exists per mole of air (units = mol mol-1)</li> <li>mass mixing ratio: constituent values are the mass of the constituent per unit volume (kg m-3)</li> </ul> </li> <li>molar mass: Molar mass of a given quantity; used in converting between mass mixing ratio and volume mixing ratio</li> <li>thermodynamically active: thermodynamically active constituents in CAM-SIMA can be found in <code>src/data/air_composition.F90</code></li> <li>minimum value: The scheme <code>qneg</code> will set constituent values that are less than the minimum to the minimum</li> </ul> </li> </ul>"},{"location":"design/constituents/#cam-sima-constituent-handling","title":"CAM-SIMA constituent handling","text":""},{"location":"design/constituents/#determining-constituents","title":"Determining constituents","text":"<p>There are three ways to identify a quantity as a constituent in CAM-SIMA:</p> <ol> <li>Constituent is provided by host (CAM-SIMA):<ul> <li>Host model constituents allow for constituents to be added as a constituent independent of the physics being run</li> <li>Host constituents are added in <code>cam_register_constituents</code> (in <code>src/control/cam_comp.F90</code>). Currently, we are always adding water vapor as a host constituent because it is expected by the SE dycore.</li> </ul> </li> <li>Constituent is a build-time physics constituent in a CCPP-ized scheme:<ul> <li>If a quantity is known to be a constituent at build-time, it is identified in the metadata for the scheme with: <code>advected = True</code></li> </ul> </li> <li>Constituent is a run-time physics constituent in a CCPP-ized scheme:<ul> <li>Sometimes, a scheme does not know what constituents it will require until run-time. In this case, an array of constituent properties (one for each needed constituent) is returned from the cam register phase. An example of how this works can be found in <code>src/physics/ncar_ccpp/musica/micm/micm.F90</code></li> </ul> </li> </ol>"},{"location":"design/constituents/#registering-initializing-constituents","title":"Registering &amp; Initializing Constituents","text":"<p>The registration and initializaiton of the constituent data array and the constituent properties object are done through calls to the generated CCPP cap.</p> <ul> <li>cam_ccpp_register_constituents: combines the three sources of constituents into one <code>ccpp_model_constituents_t</code> object<ul> <li>Called before the physics grid (which requires the number of constituents) is initialized</li> </ul> </li> <li>cam_ccpp_initialize_constituents: initializes the data array within the <code>ccpp_model_constituents_t</code> object<ul> <li>Called after the physics grid is initialized (so we know the size of the array allocate)</li> <li>The array is initialized to (columns, levels, number of constituents)</li> </ul> </li> </ul>"},{"location":"design/constituents/#constituent-usage","title":"Constituent Usage","text":""},{"location":"design/constituents/#adding-to-the-ccpp-constituents-object","title":"Adding to the CCPP constituents object","text":""},{"location":"design/constituents/#build-time-static-constituents","title":"Build-time (static) constituents","text":"<p>Build-time constituents are those that you know your scheme will always need. These constituents are treated almost as if they were normal arguments. To tell the CCPP Framework that a given argument is a constituent, you will add the following line to the metadata for that variable:</p> <pre><code>advected = True\n</code></pre> <p>This instructs the framework to handle that variable (you will not need to add it to the registry or anywhere else in the model). The framework will generate the code to allocate and initialize all constituents, and will also create and handle the associated tendency variable (which will be accessible via metadata with the standard name <code>tendency_of_&lt;const_stdname&gt;</code> and the metadata property <code>constituent = true</code>)</p>"},{"location":"design/constituents/#run-time-dynamic-constituents","title":"Run-time (dynamic) constituents","text":"<p>Run-time constituents are those that are conditional on the configuration of the model. If your scheme has runtime constituents, you will instantiate them in the register phase of your scheme. Example Fortran is below:</p> <pre><code>!&gt; \\section arg_table_&lt;scheme&gt;_register Argument Table\n!! \\htmlinclude &lt;scheme&gt;_register.html\nsubroutine &lt;scheme&gt;_register(constituent_props, filename, errmsg, errcode)\n  use ccpp_constituent_prop_mod, only: ccpp_constituent_properties_t\n\n  type(ccpp_constituent_properties_t), allocatable, intent(out) :: constituent_props(:)\n  character(len=256),                               intent(in)  :: filename\n  character(len=512),                               intent(out) :: errmsg\n  integer,                                          intent(out) :: errcode\n\n  integer :: const_idx\n  character(len=512), allocatable :: const_names(:)\n\n  ! Read the file and determine what constituents are needed at runtime\n  ! Allocate and populate const_names with those constituents\n\n  ! Allocate the constituent properties array\n  allocate(constituent_props(size(const_names)), stat=ierr)\n  if (ierr /= 0) then\n     errcode = 1\n     errmsg = 'Failed to allocate \"constituent_props\"'\n     return\n  end if\n\n  ! Instantiate each constituent\n  do const_idx = 1, size(const_names)\n     ! Instantiate call may vary based on the properties of each runtime constituent\n     call constituent_props(const_idx)%instantiate( &amp;\n             std_name = const_names(const_idx), &amp;\n             long_name = const_names(const_idx), &amp;\n             units = 'kg kg-1', &amp;\n             vertical_dim = 'vertical_layer_dimension', &amp;\n             min_value = 0.0_kind_phys, &amp;\n             advected = .true., &amp;\n             water_species = .true., &amp;\n             mixing_ratio_type = 'wet', &amp;\n             errcode = errcode, &amp;\n             errmsg = errmsg)\n     if (errcode /= 0) then\n        return\n     end if\n  end do\n\nend subroutine &lt;scheme&gt;_register\n</code></pre> <p>Note that only scalar variables may be passed into the register phase as the grid has not yet been set up when the CCPP register phases are called. The metadata for the above routine is below.</p> <p>Standard name for runtime constituents variable</p> <p>The only requirement for this standard name is that it is unique.</p> <pre><code>[ccpp-arg-table]\n  name = &lt;scheme&gt;_register\n  type = scheme\n[ constituent_props ]\n  standard_name = dynamic_constituents_for_&lt;scheme&gt;\n  units = none\n  dimensions = (:)\n  allocatable = True\n  type = ccpp_constituent_properties_t\n  intent = out\n[ filename ]\n  standard_name = filename_for_runtime_constituents\n  units = none\n  dimensions = ()\n  type = character | kind = len=256\n  intent = in\n[ errmsg ]\n  standard_name = ccpp_error_message\n  long_name = Error message for error handling in CCPP\n  units = none\n  type = character | kind = len=512\n  dimensions = ()\n  intent = out\n[ errcode ]\n  standard_name = ccpp_error_code\n  long_name = Error flag for error handling in CCPP\n  units = 1\n  type = integer\n  dimensions = ()\n  intent = out\n\n</code></pre>"},{"location":"design/constituents/#accessing-the-ccpp-constituent-object","title":"Accessing the CCPP constituent object","text":"<p>Constituent values and properties can be accessed from the host side and from the physics in the following ways:</p> <ul> <li>Host side: constituents and properties can be accessed via the host model and dycore by way of the <code>cam_constituents.F90</code> module, which is an interface to the CCPP cap, which is in turn an interface to the constituents object</li> <li>Physics: the constituent array, constituent tendencies, and/or the constituent properties object are passed into a scheme via the following metadata (the local name and intent may vary):</li> </ul> <pre><code>[ q ]\n  standard_name = ccpp_constituents\n  units = none\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent,vertical_layer_dimension,number_of_ccpp_constituents)\n  intent = in\n[ qtend ]\n  standard_name = ccpp_constituent_tendencies\n  units = none\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent,vertical_layer_dimension,number_of_ccpp_constituents)\n  intent = inout\n[ const_props ]\n  standard_name = ccpp_constituent_properties\n  units = None\n  type = ccpp_constituent_prop_ptr_t\n  dimensions = (number_of_ccpp_constituents)\n  intent = in\n</code></pre>"},{"location":"design/constituents/#ccpp-framework-constituent-handling","title":"CCPP Framework constituent handling","text":"<p>This section can be removed when constituents are documented in the CCPP Framework documentation.</p>"},{"location":"design/constituents/#constituent-object-fortran","title":"Constituent object (Fortran)","text":"<p>The constituent object (found in <code>$CAM-SIMA/ccpp_framework/src/ccpp_constituent_prop_ mod.F90</code>) is a flexible and extendable means of containing necessary constituent data for the framework. The primary object is <code>ccpp_model_constituents_t</code>.</p> <p></p> <p>This object, importantly, contains the following properties (for which there is metadata; CCPP standard name in parenthesis):</p> <ul> <li><code>const_metadata</code> (ccpp_constituent_properties)</li> <li><code>num_layer_vars</code> (number_of_ccpp_constituents)</li> <li><code>num_advected_vars</code> (number_of_ccpp_advected_constituents)</li> <li><code>vars_layer</code> (ccpp_constituents)</li> </ul> <p>The <code>const_metadata</code> property is of type <code>ccpp_constituent_prop_ptr_t</code>, which contains a pointer to a <code>ccpp_constituent_properties_t</code> object, as depicted above. This object contains all of the constituent properties for the constituents in the constituents array, with the same indices as the constituents array.</p> <p>The <code>ccpp_model_constituents_t</code> type also contains a hash table of constituent properties for more efficient searching, as well as several methods used by the generated cap code. Some methods are highlighted below:</p> <ul> <li>new_field: add a new constituent\u2019s set of metadata fields to the hash table</li> <li>lock_table: lock the constituent hash table and initialize the constituent array<ul> <li>Initializes the constituent array to the default value specified for each constituent (min value held in constituent props array for each constituent)</li> <li>Packs the advected constituents at the front of the constituents array</li> </ul> </li> <li>const_index: retrieves the constituent index for a constituent (provided the standard name)</li> </ul>"},{"location":"design/constituents/#code-generation-python","title":"Code generation (python)","text":"<p>The constituents-related code generation routines provide an interface to the constituents object. These routines can be found in <code>$CAM-SIMA/ccpp_framework/scripts/constituents.py</code>, primarily within the \u201cwrite_host_routines\u201d function. The (most often used) generated routines related to constituents are:</p> <ul> <li>&lt;hostname&gt;_ccpp_register_constituents</li> <li>&lt;hostname&gt;_ccpp_initialize_constituents</li> <li>&lt;hostname&gt;_ccpp_number_constituents</li> <li>&lt;hostname&gt;_constituents_array</li> <li>&lt;hostname&gt;_model_const_properties</li> <li>&lt;hostname&gt;_const_get_index</li> </ul> <p>The routines above are generated during <code>./preview_namelists</code> or <code>./case.build</code> and can be found here: <code>$CASE/bld/atm/obj/ccpp/cam_ccpp_cap.F90</code></p>"},{"location":"design/directory-structure/","title":"CAM-SIMA directory structure","text":"<p>This page lists out the directory structure for CAM-SIMA, and what the general purpose of each directory and subdirectory is.</p>"},{"location":"design/directory-structure/#overview","title":"Overview","text":"<p>Linked directories represent externals submodules (except .lib/git-fleximod, which is not a submodule but instead code copied from the external repository) <pre>\nCAM-SIMA\n|-- .github\n|-- .lib/git-fleximod\n|-- bin\n|-- ccpp_framework\n|-- ccs_config\n|-- cime\n|-- cime_config\n|-- components\n|   |-- cdeps\n|   |-- cice\n|   |-- cism\n|   |-- clm\n|   |-- cmeps\n|   |-- mizuRoute\n|   |-- mosart\n|   |-- rtm\n|-- docker\n|-- libraries\n|   |-- FMS\n|   |-- parallelio\n|-- share\n|-- src\n|   |-- control\n|   |-- core_utils\n|   |-- cpl\n|   |   |-- nuopc\n|   |-- data\n|   |-- dynamics\n|   |   |-- mpas\n|   |   |   |-- assets\n|   |   |   |-- driver\n|   |   |   |-- dycore\n|   |   |-- none\n|   |   |-- se\n|   |   |   |-- dycore\n|   |   |-- tests\n|   |   |   |-- initial_conditions\n|   |   |-- utils\n|   |-- history\n|   |-- physics\n|   |   |-- ncar_ccpp\n|   |   |-- utils\n|   |-- utils\n|-- test\n|   |-- system\n|   |-- unit\n|   |   |-- sample_files\n|-- tools\n</pre></p>"},{"location":"design/directory-structure/#top-level-external-directories","title":"Top-level external directories","text":"<p>These directories contain external repository source code, libraries, or tools, and usually are only present after <code>bin/git-fleximod update</code> has been run.</p> <p>Please note that any modifications to the source code in these directories should generally be made outside of CAM-SIMA and instead in the associated external repository listed below.</p>"},{"location":"design/directory-structure/#bin","title":"bin/","text":"<p>Contains the <code>git-fleximod</code> tool for downloading needed source code and software from external repositories.  More information on <code>git-fleximod</code> can be found here.</p>"},{"location":"design/directory-structure/#ccpp_framework","title":"ccpp_framework/","text":"<p>Contains the core CCPP-framework source code and tools.</p>"},{"location":"design/directory-structure/#ccs_config","title":"ccs_config/","text":"<p>Contains the configuration files used by CIME to properly configure and build a CAM-SIMA (or CESM) case.  The Github repository associated with this directory can be found here.</p>"},{"location":"design/directory-structure/#cime","title":"cime/","text":"<p>Contains the Common Infrastructure for Modeling the Earth (CIME) tools and associated libraries.  Used by CAM-SIMA and CESM for the general configuration and building of a simulation (or \"case\"). See more on CIME usage in the Creating, configuring, and running a case section.</p>"},{"location":"design/directory-structure/#components","title":"components/","text":"<p>Contains the following other CESM components:</p> <ul> <li>Community Data Models for Earth Prediction Systems (CDEPS)</li> <li>Community Ice CodE sea ice model (CICE)</li> <li>Community Ice Sheet Model (CISM)</li> <li>Community Terrestrial Systems Model (CTSM/CLM)</li> <li>Community Mediator for Earth Prediction Systems (CMEPS)</li> <li>Reach-based river routing model (mizuRoute)</li> <li>MOdel for Scale Adaptive River Transport (MOSART)</li> <li>River Transport Model (RTM)</li> </ul>"},{"location":"design/directory-structure/#libraries","title":"libraries/","text":"<p>Contains the following external libraries:</p> <ul> <li>Flexible Modeling System (FMS)</li> <li>Parallel IO (PIO)</li> </ul>"},{"location":"design/directory-structure/#share","title":"share/","text":"<p>Contains source code shared across all CESM components.</p>"},{"location":"design/directory-structure/#top-level-cam-sima-directories","title":"Top-level CAM-SIMA directories","text":"<p>These directories represent code and tools that is solely contained within the CAM-SIMA repository.  If there is a sub-directory that is also an external submodule or repository it will be marked with the \"(external)\" label.</p>"},{"location":"design/directory-structure/#cime_config","title":"cime_config/","text":"<p>Contains the SIMA-specific python and XML configuration routines used by CIME and the CCPP-framework to properly configure and build a CAM-SIMA simulation, including the CCPP-generated caps and namelist files.</p> <p>Subdirectories:</p> <ul> <li>testdefs - Location of the CAM-SIMA regression test list and associated files used by CIME during regression (system) testing.<ul> <li>testmods_dirs/cam - Location of CAM-SIMA case configuration files used during CIME regression testing.</li> </ul> </li> </ul>"},{"location":"design/directory-structure/#docker","title":"docker/","text":"<p>Contains files needed to run certain CAM-SIMA configurations in a docker container.</p>"},{"location":"design/directory-structure/#src","title":"src/","text":"<p>Contains all of the SIMA-specific source code needed to run the model. Additional details can be found below in the Source directories section.</p>"},{"location":"design/directory-structure/#test","title":"test/","text":"<p>Contains everything needed to perform software testing and validation of CAM-SIMA source code.</p> <p>Subdirectories:</p> <ul> <li>system/ - Includes scripts needed to run CIME (integration) regression tests.</li> <li>unit/   - Includes scripts and source code needed to run CAM-SIMA unit tests.<ul> <li>sample_files/ - Contains files that are used to validate the unit test results.</li> </ul> </li> </ul>"},{"location":"design/directory-structure/#tools","title":"tools/","text":"<p>Contains non-required scripts and source code that may be useful for CAM-SIMA development.</p>"},{"location":"design/directory-structure/#source-src-directories","title":"Source (src) directories","text":"<p>This section lists all of the directories underneath the \"src\" top-level directory.</p>"},{"location":"design/directory-structure/#control","title":"control/","text":"<p>Contains all of the source code needed for general model configuration, organization, and workflow, i.e. all of the \"control\" systems.</p>"},{"location":"design/directory-structure/#cpl","title":"cpl/","text":"<p>Contains all of the source code needed for SIMA to interact with a coupler</p> <p>Subdirectories:</p> <ul> <li>nuopc/ - Contains the source code needed to interact with the NUOPC coupler, which is brought in via the CMEPS external.</li> </ul>"},{"location":"design/directory-structure/#data","title":"data/","text":"<p>Contains all of the source code needed to manage internal model data.  This includes auto-generated registry and initial conditions files code, physical constants, and atmospheric composition and thermodynamic properties.</p>"},{"location":"design/directory-structure/#dynamics","title":"dynamics/","text":"<p>Contains all of the dynamical core (dycore) source code.</p> <p>Subdirectories:</p> <ul> <li>mpas/ - Contains all of the source code needed for SIMA to properly couple to the Model for Prediction Across Scales (MPAS) dynamical core.<ul> <li>assests/ - Contains helper scripts, makefiles, and other files that are needed or useful but don't have scientific model source code.</li> <li>driver/ - Contains the MPAS &lt;-&gt; SIMA interface source code.</li> <li>dycore/ (external) - External submodule that contains the MPAS dycore code.</li> </ul> </li> <li>none/ - Contains the \"null\" dycore source code, which allows physics and chemistry routines to be forced with atmospheric data coming directly from input files as opposed to dycore calculations.</li> <li>se/ - Contains all of the source code needed for SIMA to properly couple to the Spectral Element dynamical core.<ul> <li>dycore/ - Contains the internal SE dycore source code files.</li> </ul> </li> <li>tests/ - Contains the source code needed to configure analytic initial conditions for dycores.<ul> <li>initial_conditions/ - Contains source code needed to configure specific analytic initial conditions formulations.</li> </ul> </li> <li>utils/ - Contains utility code used by all dycores in SIMA.</li> </ul>"},{"location":"design/directory-structure/#physics","title":"physics/","text":"<p>Contains all of the SIMA physics and chemistry source code.</p> <p>Subdirectories:</p> <ul> <li>ncar_ccpp/ (external) - External submodule that contains all of the code in the atmospheric_physics repo.<ul> <li>The directory structure for atmospheric_physics can be found in the atmospheric_physics directory structure section.</li> </ul> </li> <li>utils/ - Contains SIMA-specific utility routines for working with the CCPP-framework and CCPP-ized physics routines.</li> </ul>"},{"location":"design/directory-structure/#utils","title":"utils/","text":"<p>Contains source code for generic SIMA utility routines that can be used throughout the model.</p>"},{"location":"design/history/","title":"History &amp; model output","text":"<p>CAM-SIMA history is the mechanism for configuring and generating diagnostic output from a model run. It is also used to generate initial-data files and aids in the model-restart process by saving the state of diagnostic fields whose processing window (e.g., averaging, standard deviation) crosses a restart-write cycle. This page describes the implementation of CAM-SIMA history in CAM-SIMA.</p>"},{"location":"design/history/#history-initialization","title":"History Initialization","text":""},{"location":"design/history/#reading-and-processing-the-history-configuration","title":"Reading and processing the history configuration","text":"<ul> <li>The allowable history configuration keywords are defined in <code>cime_config/hist_config.py</code> in <code>_HIST_CONFIG_ENTRY_TYPES</code>.<ul> <li>Each of the keywords is configurable via the namelist (<code>user_nl_cam</code>)</li> <li>The syntax is <code>&lt;keyword&gt;;&lt;volume&gt;: &lt;value&gt;</code> (see examples below)</li> <li>Currently, these configuration keywords are as follows (the <code>atm_in</code> equivalent indicates how <code>hist_config.py</code> parses these into a namelist to be read by SIMA):</li> </ul> </li> </ul> Configuration Keyword Description atm_in equivalent hist_add_avg_fields hist_add_inst_fieldshist_add_min_fields hist_add_max_field hist_add_var_field hist_remove_fields These configuration keywords add/remove fields to the specified volume with the indicated accumulation flag (average, instantaneous, minimum, maximum, standard deviation). The closest CAM7 equivalent is \u201cfinclX\u201d &amp;hist_config_arrays_nl\u2002hist_num_avg_fields\u2002hist_num_inst_fields\u2002hist_num_min_fields\u2002hist_num_max_fields\u2002hist_num_var_fields&amp;hist_file_config_nl\u2002hist_avg_fields\u2002hist_inst_fields\u2002hist_min_fields\u2002hist_max_fields\u2002hist_var_fields hist_file_type This keyword determines the type of file. Options are: \u201chistory,\u201d \u201csatellite,\u201d and \u201cinitial_value\u201dDefaults to \u201chistory\u201d &amp;hist_file_config_nl\u2002hist_file_type hist_max_frames Indicates the maximum number of samples/frames that can be written to a file before that file is considered \u201cfull\u201d. The CAM7 equivalent is \u201cmfilt\u201d.Defaults to 1 for h0 and 30 for all other volumes. &amp;hist_file_config_nl\u2002hist_max_frames hist_output_frequency Specifies the frequency of writes to the volume. The syntax is \"&lt;integer&gt;*&lt;time period&gt;\" where \u201ctime_period\u201d can be: steps, seconds, minutes, hours, days, months, years. The closest CAM7 equivalent is \u201cnhtfrq\u201d. &amp;hist_file_config_nl\u2002hist_output_frequency hist_precision Denotes the precision for the volume. Options are \"REAL32\" and \"REAL64\".Defaults to \"REAL32\" &amp;hist_file_config_nl\u2002hist_precision hist_write_nstep0 Indicates whether or not to write the nstep=0 sample to the volume.Defaults to .false. &amp;hist_file_config_nl\u2002hist_write_nstep0 hist_filename_template Specifies the template for the filename for the volume.  Defaults to \"%c.cam.%u.%y-%m-%d-%s.nc\" where \"%c\" is the case name, \"%u\" is the volume, \"%y\" is the year, \"%m\" is the month, \"%d\" is the day, and \"%s\" is the number of seconds since midnight GMT, with the timestamp itself representing the model time when the file is created. &amp;hist_file_config_nl\u2002hist_filename_spec <ul> <li><code>hist_config.py</code> also contains the <code>HistoryVolConfig</code> class (all the info pertaining to a single history file), the <code>HistoryConfig</code> class (all the history configuration information including a dict of <code>HistoryVolConfig</code> objects), and helper classes.</li> <li>The <code>HistoryConfig</code> object is created in <code>buildnml</code> out of entries in <code>user_nl_cam</code> and written to <code>run/atm_in</code>.</li> <li>In order to ensure that all relevant runtime (namelist) values show up in <code>atm_in</code>, the <code>HistoryConfig</code> object must contain all the logic in setting default values.</li> </ul>"},{"location":"design/history/#setting-up-the-history-data-structures","title":"Setting up the history data structures","text":"<ul> <li>History namelist information is read and history data structures are set up in <code>src/history/cam_hist_file.F90</code></li> <li>The driving function in <code>cam_hist_file.F90</code> is <code>hist_read_namelist_config</code>, which is called by <code>history_readnl</code> in <code>src/history/cam_history.F90</code>. This function reads in the hist_config_arrays_nl namelist group, allocates the history field arrays, and then uses those arrays to read in the hist_file_config_nl namelist group (via a call to <code>read_namelist_entry</code>).</li> <li>The history configuration namelist options are used to populate <code>cam_history.F90</code>\u2019s module-level hist_configs array of <code>hist_file_t</code> objects (the size of this array is the number of user-configured volumes).</li> <li>The <code>hist_file_t</code> object contains information about the configuration options for a given history volume. This includes the maximum number of frames that can be written to the file, the current number of frames on the file, the name of the file, and all of the history fields to be written to the file. It also contains methods to populate the field lists (<code>config_set_up_fields</code>), set up the metadata of the file (<code>config_define_file</code>), and write history fields to the file (<code>config_write_time_dependent_variables</code>).</li> <li>Each <code>hist_file_t</code> object contains both a hash table and allocatable field list to keep track of the fields written to the file. The core class for each of these is the <code>hist_field_info_t</code> (in <code>src/history/buffers/src/hist_field.F90</code>), which contains information about a history field. This includes the field names, the accumulate flag (average, instantaneous, minimum, etc), units, type, dimensions, and fill value. It also includes the buffer(s) (type is/are <code>hist_buffer_t</code>) that will and do hold the actual data.</li> </ul>"},{"location":"design/history/#populating-the-possible-field-list","title":"Populating the possible field list","text":"<p>The possible fields to be output by the history infrastructure are tracked in <code>cam_history.F90</code> via the <code>possible_field_list</code> hash table. It is populated during init time by calls to the subroutine <code>history_add_field</code> (found in <code>src/history/cam_history.F90</code>). \u201cInit time,\u201d means that all calls to <code>history_add_field</code> must occur during the execution of <code>cam_init</code> (found in <code>src/control/cam_comp.F90</code>).</p> <ul> <li>Within the CCPP physics, this means that any diagnostic fields must be added to possible field list during _init (ideally the diagnostics are kept separate from the core scheme physics to keep the physics portable)</li> <li>Within dynamics, the fields must be added during <code>dyn_init</code> or <code>stepon_init</code></li> <li>For physics variables:<ul> <li>State variables are added to the field list in the init phase of the cam_state_diagnostics scheme in <code>src/physics/ncar_ccpp/diagnostics/cam_diagnostics.F90</code><ul> <li>This scheme is included at the end of the <code>physics_before_coupler</code> group in the suite definition file (SDF)</li> </ul> </li> <li>Tendency variables are added to the field list in the init phase of the <code>cam_tend_diagnostics</code> scheme in <code>src/physics/ncar_ccpp/diagnotics/cam_diagnostics.F90</code><ul> <li>This scheme is included at the end of the <code>physics_after_coupler</code> group in the SDF</li> </ul> </li> <li>Additional variables specific to the scheme are included in the init phase of a _diagnostics scheme in <code>src/physics/ncar_ccpp/diagnostics</code> <p>Each call to <code>history_add_field</code> adds a new field to the end of the <code>possible_field_list_head</code> linked list. At the end of <code>cam_init</code>, the possible field list linked list is used to print the list (to the atm.log* file) and then is converted to the <code>possible_field_list</code> hash table. A sample of the history field list is seen below.</p> <pre><code>  ***************** HISTORY FIELD LIST ******************\n             T          K  avg  air_temperature\n            ZM          m  avg  geopotential_height_wrt_surface\n          PHIS     m2 s-2  ins   surface_geopotential\n          PMID         Pa  avg  air_pressure\n       PDELDRY         Pa  avg  air_pressure_thickness_of_dry_air\n             Q    kg kg-1  avg  water_vapor_mixing_ratio_wrt_moist_air_and_condensed_water\n        CLDLIQ    kg kg-1  avg cloud_liquid_water_mixing_ratio_wrt_moist_air_and_condensed_water          \n        RAINQM    kg kg-1  avg  rain_mixing_ratio_wrt_moist_air_and_condensed_water\n         TTEND      K s-1  avg  tendency_of_air_temperature_due_to_model_physics\n  *************** END HISTORY FIELD LIST ****************\n</code></pre>"},{"location":"design/history/#capturing-history-output","title":"Capturing history output","text":"<p>Outside of CAM-SIMA init and finalize time, history buffers can be populated with data via a call to <code>history_out_field</code> (found in <code>src/history/cam_history.F90</code>)</p> <p>The subroutine <code>history_out_field</code> iterates over the <code>hist_configs</code> array and populates the buffer(s) of the <code>hist_field_info_t</code> object of the <code>hist_file_t</code> object if the field name in the call is active on that file (e.g. the field was configured via the namelist to be output for that volume).</p> <ul> <li>Within the CCPP physics, calls to <code>history_out_field</code> can exist anywhere except _init and _final</li> <li>In dynamics, calls to <code>history_out_field</code> can exist anywhere except in <code>dyn_init</code>, <code>stepon_init</code>, and <code>stepon_final</code></li> <li>For physics variables, <code>history_out_field</code> calls are included in the run phase of the same schemes described in the section above.</li> </ul>"},{"location":"design/history/#defining-new-history-files","title":"Defining new history files","text":"<p>The <code>cam_history.F90</code> subroutine <code>history_write_files</code> (which is called during <code>cam_timestep_final</code>) does three main actions for each of the user-defined history volumes:</p> <ol> <li>Determine if it\u2019s time to write to the file based on the user-supplied namelist option hist_output_frequency</li> <li>If it's time to write, determine if we need to open a new file</li> <li>Write the variables to the file(s)</li> </ol> <p>The bolded step #2 above is what determines if we need to define a new history file. The situations where we would need to define a new file are:</p> <ol> <li>It's the first sample we're outputting to a specific volume.</li> <li>The last time we output to the volume, we \"filled\" the file (number of samples written to the file met the user-configured <code>hist_max_frames</code>) and closed it</li> </ol> <p>We determine if it's time for a new file with the following line of code:</p> <pre><code>   mod(num_samples, hist_configs(file_idx)%max_frame()) == 0\n</code></pre> <p>If it is indeed time to define a new file, we call the <code>config_define_file</code> subroutine (which is found in <code>src/history/cam_hist_file.F90</code>) for the volume:</p> <pre><code>  call hist_configs(file_idx)%define_file(restart, logname, host, model_doi_url)\n</code></pre> <ul> <li>This subroutine opens the netcdf file(s) and writes the necessary time-independent metadata (for the file and for the history fields) and grid information.<ul> <li>Note that there will be a maximum of TWO (2) files opened at this stage. If there are both instantaneous fields AND accumulated fields (average, minimum, maximum, standard deviation) on the volume, two files will be created (hXi AND hXa); otherwise, only the relevant file will be created (hXi OR hXa)</li> </ul> </li> </ul>"},{"location":"design/history/#writing-a-history-file","title":"Writing a history file","text":"<p>The <code>cam_history.F90</code> subroutine <code>history_write_files</code> (which is called during <code>cam_timestep_final</code>) does three main actions for each of the user-defined history volumes:</p> <ol> <li>Determine if it\u2019s time to write to the file based on the user-supplied namelist option hist_output_frequency</li> <li>If it's time to write, determine if we need to open a new file</li> <li>Write the variables to the file(s)</li> </ol> <p>The bolded step #3 above occurs any time the criteria for #1 is satisfied. At this point, the following call is made to write the history fields (whose data has been stored in their buffers via calls to <code>history_out_field</code>):</p> <pre><code>  call hist_configs(file_idx)%write_time_dependent_variables(file_idx, restart)\n</code></pre> <p>It is during this call that we increment the number of samples written for this volume and actually write the data held within the buffer(s) to the netcdf file (as well as the time-dependent metadata for the fields).</p>"},{"location":"design/history/#defining-history-restart-files","title":"Defining history restart files","text":"<p>Restarts not yet implemented in CAM-SIMA</p>"},{"location":"design/history/#writing-a-history-restart-file","title":"Writing a history restart file","text":"<p>Restarts not yet implemented in CAM-SIMA</p>"},{"location":"design/history/#reading-a-history-restart-file","title":"Reading a history restart file","text":"<p>Restarts not yet implemented in CAM-SIMA</p>"},{"location":"design/sima-design-goals/","title":"Design goals &amp; features","text":"<p>Motivated by the Singletrack project (a precursor to SIMA), the CAM-SIMA project was created to build a new CAM infrastructure to meet the SIMA science and computational needs. This page documents those needs and some of the features that implement them.</p>"},{"location":"design/sima-design-goals/#cam-needs-to-be-more-run-time-configurable","title":"CAM needs to be more run-time configurable","text":"<ul> <li>To make CAM and CESM more available, e.g., for usage in containers and the cloud, a build of CAM should be more configurable than it is at present.</li> <li>One feature that makes CAM more run-time configurable is moving physics suites to the CCPP. By allowing CAM to compile in more than one physics suite, the physics suite can be selected at run time (e.g., as a namelist variable).</li> <li>Another feature needed to make CAM more run-time configurable is making dycores themselves more run-time configurable. For instance, the SE dycore will no longer require the number of advected constituents to be specified at compile time.</li> </ul>"},{"location":"design/sima-design-goals/#remove-obstacles-to-use-of-specialized-high-performance-processing-units-eg-gpus-fpgas","title":"Remove obstacles to use of specialized high-performance processing units (e.g., GPUs, FPGAs)","text":"<p>The chunk structure in CAM physics served its purpose when threading was the only way to accelerate code. However, to make the best use of both threading and modern accelerators, a flexible chunking mechanism is required. The new infrastructure enables this by using flat arrays for all fields.</p> <ul> <li>Moving to flexible precision of data is important for being able to test both performance improvements and the affect on model quality. The CCPP is explicitly designed to allow for compile-time selection of precision at the physics suite level as well as for individual fields. In addition, the new infrastructure is explicitly designed to handle the case where the dycore is running at a different precision than the physcs (i.e., by using proper field promotion and demotion primitives).</li> <li>Pointers in Fortran are less efficient because they prevent some optimization techniques. The new infrastructure avoids pointers as much as possible by making use of the automatic data management capability of the CCPP (which does not create pointers).</li> <li>The new infrastructure provides greater flexibility in that the model can be built with multiple physics suites to increase run-time flexibility. There is a tradeoff in that building more physics suites will often increase build time. Builds with a single suite should be faster than now since only the schemes that are required for the suite are compiled (currently most schemes are compiled all the time even if they will not be used).</li> </ul>"},{"location":"design/sima-design-goals/#modularity","title":"Modularity","text":"<p>In order to continue to allow CAM to grow without an ever increasing cost of bringing in new features, CAM must be more modular. A classic example is chemistry which ACOM would like to make modular but which is currently entwined with CAM in many areas (e.g., code in CAM repository, extensive configuration code dedicated to chemistry, extensive namelist building code and data dedicated to chemistry, large number of use cases containing chemistry configuration data). The new CAM infrastructure contains features to increase modularity.</p> <ul> <li>Support for multiple namelists. This allows modular components to contain their own namelist (run-time configuration options). The active namelists are combined to produce atm_in.</li> <li>Flexible handling of constituent information. Modular components can provide constituent information via metadata (if component is a CCPP scheme) or at run time.</li> </ul> <p>Modularity will allow CAM to move components to external repositories. This process cuts development costs for both CAM and for the component (e.g., as has happened with PUMAS). Some ways this is accomplished are listed here:</p> <ul> <li>Code reviews are more efficient since CAM SEs do not have to review every routine in the external module so they can just focus on the interfaces. The external developers do not have to be involved in CAM modifications.</li> <li>Externals can develop and maintain they own namelist definition files, they do not have to coordinate with the larger CAM namelist (which itself has been broken into several smaller namelists).</li> <li>Namelists associated with physics schemes do not have to have separate namelist-reading code. The new infrastructure automatically creates an appropriate Fortran module to read in the runtime data from atm_in. The system then also ensures that all active namelists are called at run time. This process ensures that namelists are always read correctly while not requiring coding or reviews to keep up to date with namelist changes.</li> </ul> <p>Use of the CCPP to build physics suites also makes CAM more modular because the CCPP treats physics schemes as modular which allows flexibility in building physics suites. The CCPP takes care of making sure variables are available before they are used and also builds the code currently handled via hand-written code in the various versions of physpkg.F90.</p>"},{"location":"design/sima-design-goals/#run-time-data-checking","title":"Run-time data checking","text":"<p>CAM needs data to run but the data needs vary with the simulation. The new infrastructure facilitates this.</p> <ul> <li>Before running physics, the new infrastructures queries the physics suite as to what input fields are required (using a CCPP interface). Then it makes sure that all of these fields have been initialized or reads the values from the initial data file. Any uninitialized fields that are not found on the initial data file will trigger a run-time error.</li> </ul>"},{"location":"design/sima-design-goals/#efficient-offline-testing-and-simulation","title":"Efficient offline testing and simulation","text":"<p>CAM currently has a few ways to run offline testing (e.g., SCAM, PORT). The new infrastructure builds these capabilities in for more efficient and flexible use.</p> <ul> <li>The new infrastructure has the ability to run without a dycore.</li> <li>Offline mode (NULL dycore) can be run with any number of columns.</li> <li>Offline mode does not required gridded input.</li> </ul>"},{"location":"design/sima-design-goals/#software-quality-control","title":"Software quality control","text":"<p>To enable efficient quality control, the new infrastructure implements a number of continuous integration (CI) techniques.</p> <ul> <li>To implement all the flexibility mentioned above, the new infrastructure makes extensive use of python scripts.<ul> <li>Python scripts make extensive use of python doctests (for simpler tests).</li> <li>There are python unit tests to cover more complicated situations.</li> <li>The GitHub CI also runs a static analysis tool (pylint) to provide feedback on potential coding issues.</li> <li>Python tests can easily be run by hand but are also automatically run on GitHub</li> </ul> </li> <li>The new infrastructure will use offline mode (see above) to run many physics configurations quickly without requiring large machines.<ul> <li>This will enable quick testing during development on a laptop.</li> <li>We hope many of these tests can also be run automatically on GitHub.</li> </ul> </li> </ul>"},{"location":"development/cam-coding-standards/","title":"Coding standards","text":"<p>The standards in this document are largely prescriptive, i.e., they should be followed.</p> <ul> <li>MUST: Exceptions must be discussed and agreed to by the CAM SEs and noted in this document.</li> <li>SHOULD: Exceptions must be approved by the CAM SEs and documented in the ChangeLog.</li> </ul> <p>While some legacy code will not follow these rules, efforts SHOULD be made to improve the code whenever you are working on it (e.g., bug fixes, enhancements).</p>"},{"location":"development/cam-coding-standards/#general-coding-standards","title":"General coding standards","text":""},{"location":"development/cam-coding-standards/#must","title":"MUST","text":"<ul> <li>Always use spaces instead of tabs</li> <li>No trailing spaces (i.e., no spaces at the end of a line)</li> </ul> <p>See tips for configuring editors</p>"},{"location":"development/cam-coding-standards/#should","title":"SHOULD","text":"<ul> <li>Use comments to explain the purpose of the following code and/or include any important but non-obvious information. When working with code, always check the comments to make sure they are still correct and useful.</li> <li>Do not use comments to 'save code for later in case it might be useful'.</li> <li>Do not include a comment that merely restates the following code logic (e.g., 'Loop over variables')</li> </ul>"},{"location":"development/cam-coding-standards/#python-coding-standards","title":"Python coding standards","text":"<p>We expect all python code to pass with a perfect score (10) using <code>pylint</code> with this version of <code>pylintrc</code>. However, external repos may have their own <code>pylintrc</code> version depending on their needs.</p> <p>We also expect all python files to follow the black code style and format.</p> <p>Finally, one can also follow the Google Python Style Guide.</p>"},{"location":"development/cam-coding-standards/#fortran-coding-standards","title":"Fortran coding standards","text":"<p>The standards described in this section represent the CAM Fortran standards. Other Fortran standards:</p> <ul> <li>CTSM Fortran Standards</li> <li>MOM Fortran Standards</li> </ul>"},{"location":"development/cam-coding-standards/#must_1","title":"MUST","text":"<ul> <li>No naked <code>use</code> statements</li> <li>No continued single-line <code>if</code> statements (i.e., all <code>if</code> statements should have a <code>then</code> if the statement is on more than one line)</li> <li>Every namelist variable in each active namelist group is present in the namelist file. An active namelist group is one which may be read during the current run.</li> <li>All namelist variables except for logical quantities are initialized to invalid values (integer: <code>-HUGE(1)</code>, real: <code>NaN</code>, character: <code>'UNSET'</code>).</li> <li>Functions may not have side effects, and should include the <code>pure</code> keyword.</li> <li>Do not combine statements on a single line (i.e., avoid use of the semi-colon to combine statements).</li> <li>Use <code>intent</code> for dummy arguments except for pointers.</li> <li>All variables of type real must have a specified kind, including literals.  For example, use <code>1.5_r8</code>, not <code>1.5</code> or <code>1.5D0</code>. Literals must also include the decimal point.</li> <li>All character declarations must use Fortran 90+ syntax (e.g., <code>character(len=*)</code> or <code>character(len=CL)</code>).</li> <li>All variable declarations must use Fortran 90+ syntax (i.e., must include the double colon between the attributes and the variable name).</li> <li>All type and procedure declarations must use Fortran 90+ syntax (i.e., must include the double colon before the type or procedure name).</li> <li>All modules should include an <code>implicit none</code> statement in the preamble (after the <code>use</code> statements). Module routines then do not need this statement.</li> <li>All optional arguments must be passed via keyword (e.g. use <code>call subroutine(x, optional_y=y)</code> instead of <code>call subroutine(x, y)</code> for the optional variable <code>optional_y</code>).</li> <li>Initialize local (non-parameter) variables in subroutines and functions at the top of the executable code, NOT on a variable declaration lines.<ul> <li>Initializing a local variable on a declaration line invokes the <code>SAVE</code> attribute and is not thread safe.</li> <li>Local pointer variables MUST be initialized before other (non-initialization) statements. By default, use the <code>nullify</code> statement.</li> </ul> </li> <li>All variables that are on the physics grid must have their horizontal dimension declared with <code>pcols</code>, even if only a subset of the variable is used in the subroutine or function. </li> </ul>"},{"location":"development/cam-coding-standards/#should_1","title":"SHOULD","text":"<ul> <li>Avoid use of preprocessor directives (e.g., <code>#if</code>, <code>#ifdef</code>). Always try for runtime variable logic instead.</li> <li>Keep formula statements relatively short. Use temporary variables to break long formulas into easier-to-read sections.</li> <li>Use subroutines to avoid repeated (cut and paste) code logic.</li> <li>Avoid side effects in subroutines. Pass variables to routines instead of 'using' them from elsewhere.  </li> <li>Use the <code>pure</code> keyword if a subroutine has no side effects.</li> <li>List dummy arguments one per line, however, related items may be grouped.</li> <li>Dummy argument order should match the order in the argument list.</li> <li>Use symbolic numerical comparison operators (e.g., <code>==</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;=</code>) not old character versions (e.g., <code>.eq.</code>).</li> <li>Avoid the use of pointers as dummy arguments (exceptions must be discussed in design or code review)</li> <li>Modules should be default <code>private</code>. Public interfaces are declared after the <code>private</code> declaration.</li> <li><code>private</code> module interfaces (i.e., subroutines and functions) should be declared private in the module header.</li> <li>Module names should conform to their filename (i.e., the module name should be the filename without the <code>.F90</code>).</li> <li>Functions should use the <code>pure</code> attribute. If they cannot, the reason should be included as a comment in the function's preamble.</li> <li>All functions and subroutines should avoid un-necessary statements (e.g. a blank <code>return</code> at the end of a subroutine).</li> <li><code>use</code> statements should be brought in at the smallest scope possible (e.g. inside individual subroutines instead of at the module level).</li> </ul>"},{"location":"development/cam-coding-standards/#indentation-and-style","title":"Indentation and style","text":"<ul> <li>Scoping: Indentation should follow scope. That is, whenever entering a new scope (e.g., <code>module</code>, <code>subroutine</code>, <code>if</code>, <code>do</code>), indent that scope relative to the scoping statement (recommended 2 spaces but each module should at least be self consistent).</li> <li>A single line should be less than 133 characters long.</li> <li>Continue lines: Indent continue lines 4 spaces or align with similar lines in statement.</li> <li>Use spaces to ease reading statements (e.g., before and after operators, after commas except in a dimensions list)</li> <li>Include a space after <code>if</code>, <code>else</code>, <code>end</code>, <code>do</code>, and <code>while</code>.</li> <li>Include a space before and after <code>::</code></li> <li>No space after <code>only</code>, i.e., <code>only:</code>, not <code>only :</code>.</li> <li>When aligning code for readability, commas go immediately after a symbol (no space).</li> </ul>"},{"location":"development/cam-coding-standards/#tips-for-configuring-editors","title":"Tips for configuring editors","text":""},{"location":"development/cam-coding-standards/#emacs-add-to-your-emacs-file","title":"emacs (add to your <code>.emacs</code> file)","text":"<ul> <li>To automatically remove trailing spaces whenever you save a file:</li> </ul> <pre><code>(add-hook 'before-save-hook 'delete-trailing-whitespace)\n</code></pre> <ul> <li>To automatically indent with spaces instead of tabs:</li> </ul> <pre><code>(setq-default indent-tabs-mode nil)\n</code></pre> <ul> <li>To use 4 spaces for each indent:</li> </ul> <pre><code>(setq tab-width 4)\n</code></pre>"},{"location":"development/cam-coding-standards/#vi-add-to-your-vimrc-file","title":"vi (add to your <code>.vimrc</code> file)","text":"<ul> <li>To automatically remove trailing spaces whenever you save a file:</li> </ul> <pre><code> autocmd BufWritePre * :%s/\\s\\+$//e\n</code></pre>"},{"location":"development/cam-sima-workflow/","title":"Development workflow for CAM-SIMA","text":"<p>This page describes the general workflow for adding new development to the CAM-SIMA repository.</p>"},{"location":"development/cam-sima-workflow/#workflow-summary","title":"Workflow summary","text":"<p>The general workflow for adding a feature, bug-fix, or modification to CAM-SIMA is as follows:</p> <ol> <li>Open an issue</li> <li>Add your code modifications</li> <li>Open a PR<ul> <li>If you know that this PR will need an official tag, then also add the tag name to the PR description.</li> </ul> </li> <li>Respond to any reviewer requests.</li> <li>Fix any failing tests</li> <li>Run the manual regression tests<ul> <li>Update <code>$CAM-SIMA/test/existing-test-failures.txt</code> if there are new tests failing or if existing test failures have been fixed.</li> </ul> </li> <li>Confirm with the CAM-SIMA gatekeeper that you are OK to merge. Then squash the commits and merge the PR (e.g. the \"squash and merge\" option).</li> <li>Make a tag (if regression test answers have changed)</li> <li>Archive baselines (if tag has been made)</li> </ol>"},{"location":"development/cam-sima-workflow/#workflow-details","title":"Workflow details","text":"<p>The following sections describe various workflow actions in more detail.</p>"},{"location":"development/cam-sima-workflow/#open-an-issue","title":"Open an issue","text":"<p>It is generally recommended to open an issue for any new features that will be added or bug that has been found that will need to be fixed. There is currently no offiical requirement on what should be contained within the issue text, so generally just put any information you think might be relevant.</p>"},{"location":"development/cam-sima-workflow/#add-your-code-modifications","title":"Add your code modifications","text":"<ol> <li>If you haven't already, create a fork. Specific instructions can be found here.</li> <li>Create a branch on your fork off of the head of the ESCOMP remote's <code>development</code> branch. Specific commands can be found here</li> <li>Apply your code modifications and/or script additions, and perform at least one test making sure your modifications work as expected. See below for Git commands for committing to your branch.</li> </ol> <p>There are multiple ways to do commit your changes, but one of the safer ways is to first check your status:</p> <pre><code>git status\n</code></pre> <p>This will provide a list of all modified files. For each one of those files whose modifications you want to add to the main package, you will do the following:</p> <pre><code>git add updated_fortran_file.F90\n</code></pre> <p>Where <code>updated_fortran_file.F90</code> should be replaced with whatever your file name is. Do this for each file you want to include. If you are confident that every file listed by <code>git status</code> needs to be added, then you can do it all at once by doing:</p> <pre><code>git add -A\n</code></pre> <p>You can then type <code>git status</code> again, at which point all of the files you added should be \"staged\" for commit (green).</p> <p>To commit your changes to your local branch:</p> <pre><code>git commit -m \"&lt;message&gt;\"\n</code></pre> <p>where <code>&lt;message&gt;</code> is a short description on sentence stating what the commits are for, e.g. \"fixed color bar bug\" or \"added significance hatching\".</p> <p>To push your changes to your fork:</p> <pre><code>git push\n</code></pre> <p>or, if you want to be more explicit,</p> <pre><code>git push origin &lt;branch name&gt;\n</code></pre>"},{"location":"development/cam-sima-workflow/#open-a-pr","title":"Open a PR","text":"<ol> <li>Go to the ESCOMP CAM-SIMA repo, and click on the \"Pull requests\" tab.  </li> <li>There, you should see a \"New pull request\" button, which you should click.  </li> <li>On the new \"Compare changes\" page, you should see a \"compare across forks\" link, which you should click.  </li> <li>You should now see two new pull-down boxes (to the right of an arrow). Using these pull-down boxes, select the \"development\" branch of the ESCOMP repo and select your fork (which should be <code>&lt;username&gt;/CAM-SIMA</code>)</li> <li>Then select the branch which contains the commits.  </li> <li>You should then see a list of all the different modifications. If they generally look correct, click the \"Create pull request\" button</li> <li>A new page should appear. In the first text box, add the title of your pull request. The second text box will contain additional fields that you should fill out to the best of your ability.</li> <li>If your code changes cause answer changes, you will need a new tag. Enter the expected tag name in the PR description. More on tag conventions here.</li> <li>Add any relevant labels to the PR, add yourself as the assignee, and add any reviewers you would like to have. Otherwise, the core SE team will add reviewers for you.</li> <li>Click \"Create pull request\"</li> </ol>"},{"location":"development/cam-sima-workflow/#fix-failing-tests","title":"Fix failing tests","text":"<p>Failing unit tests will appear at the bottom of the PR page (as shown below). You will also get an email if any tests fail.  </p> <p>Click through (via <code>Details</code> link) to see the test output of the failing tests. Refer to the table below for debugging failing tests.</p> Failing test Description Resources <code>.github/workflows/fleximod_test.yaml / fleximod-test (&lt;python version&gt;) (pull_request)</code> git-fleximod test failure. Likely an invalid external git-fleximod testing <code>Python unit tests / python_unit_tests (&lt;python version&gt;) (pull_request)</code> Python unit test failure. Likely need to update sample files Python unit testing <code>Source Code Linting / source_code_tests (pull_request)</code> Python linting failure. Need to fix modified python code. Python source code linting"},{"location":"development/cam-testing/","title":"Testing","text":"<p>This page describes the various automated and manual tests that are run for CAM-SIMA whenever the code is modified, as well as instructions for how to add new tests.</p>"},{"location":"development/cam-testing/#regression-testing","title":"Regression Testing","text":""},{"location":"development/cam-testing/#running-the-regression-tests-manual","title":"Running the regression tests (manual)","text":"<p>NOTE:  Regression testing on derecho should be done for every PR before merging!</p> <p>Users can manually run regression tests on Derecho to ensure that the model builds correctly in various configurations.  The tests can be run with a local copy of CAM-SIMA by using the <code>test_driver.sh</code> script under <code>$CAM-SIMA/test/system</code>.  To run the tests associated with a particular compiler option one can do the following commands:</p> <p>run git-fleximod</p> <p>Make sure you have run <code>bin/git-fleximod update</code> before you run the tests!</p> <p>For running GNU tests*:</p> <pre><code>env CAM_FC=gnu ./test_driver.sh -f\n</code></pre> <p>For running Intel tests*:</p> <pre><code>env CAM_FC=intel ./test_driver.sh -f\n</code></pre> <p>*Note: you may also have to include the environment variable <code>CAM_ACCOUNT</code> on derecho, which is your account key</p> <p>test_driver.sh default</p> <p>By default, <code>test_driver.sh</code> will compare against the baselines in <code>/glade/campaign/cesm/community/amwg/sima_baselines/latest_&lt;CAM_FC&gt;</code>. If you wish to compare against different baselines, specify the path to those baselines with the environment variable <code>BL_TESTDIR</code></p> <p>Running test_driver.sh with no baseline comparison</p> <p>If you do not wish to compare to baselines, don't use the <code>BL_TESTDIR</code> environment variable and use the flag <code>--no-bl-compare</code></p> <p>Running the script will produce a directory in your scratch space labeled <code>aux_sima_&lt;CAM_FC&gt;_&lt;timestamp&gt;</code>, where <code>&lt;CAM_FC&gt;</code> is the compiler you chose, and <code>&lt;timestamp&gt;</code> is the timestamp (starting with the date) of when the tests were started, along with a job submitted to the local batch system.</p> <p>Inside the directory you should see an executable labeled <code>cs.status.*</code>.  Running that command after the submitted job has finished will display the test results. Everything should be labeled <code>PASS</code>.  Any other label indicates that a test may have failed, and should be investigated. Expected failures can be found in the <code>$CAM-SIMA/test/existing-test-failures.txt</code> file.</p>"},{"location":"development/cam-testing/#inspecting-test-output","title":"Inspecting test output","text":"<p>If you have an unexpected FAIL or PEND or DIFF, you will want to investigate further. Start by navigating into the test directory, for example:</p> <pre><code>cd SMS_Ln9.ne5pg3_ne5pg3_mg37.FTJ16.derecho_intel.cam-outfrq_se_cslam.GC.aux_sima_intel_20241223100339\n</code></pre> <p>If you have familiarity with CAM cases, the setup and directory structure will be familiar.</p> <ul> <li>A good place to start is the <code>TestStatus.log</code> file, which will include almost all test output (including build failures and information on where to look for other failures)</li> <li>Build logs for each component are in the <code>bld</code> directory. If you look at the filenames and one or more doesn't have the <code>.gz</code> end tag, those are likely culprits for having the error.</li> <li>Run logs are in the <code>run</code> directory. Similar to the build logs, log files that aren't zipped up are candidates for containing errors. The <code>atm.log.*</code> and <code>cesm.log.*</code> files are likely going to contain the information about the error you're seeking.</li> <li>Refer to the procedures for checking metadata and running CAM-SIMA for additional debugging help</li> </ul>"},{"location":"development/cam-testing/#additional-test-info","title":"Additional test info","text":"<p>The tests themselves are listed in <code>&lt;CAM-SIMA&gt;/cime_config/testdefs/testlist_cam.xml</code>. Any files that need to be included in order for the tests to run properly are located in <code>&lt;CAM-SIMA/cime_config/testdefs/testmods_dirs/cam/outfrq_XXX</code>, where <code>XXX</code> is the name of the test.  Additional information on the CIME testing system, which is what this testing infrastructure is built on, can be found online here. </p>"},{"location":"development/cam-testing/#archiving-baselines","title":"Archiving baselines","text":"<p>If your PR changes answers, then after you have run the tests, merged your PR, and created a tag (see tag workflow), you will need to archive your baselines for the next person.</p> <p>To do this, navigate to <code>$CAM-SIMA/test/system</code> on derecho and run:</p> <pre><code>env CESM_TESTDIR=/glade/derecho/scratch/YourName/aux_sima_yyyymmddsssss CAM_FC=INTEL ./archive_baseline.sh &lt;sima tag&gt;\n</code></pre> <pre><code>env CESM_TESTDIR=/glade/derecho/scratch/YourName/aux_sima_yyyymmddsssss CAM_FC=GNU ./archive_baseline.sh &lt;sima tag&gt;\n</code></pre> <p>Baseline 'latest' symlink</p> <p>By default, <code>archive_baseline.sh</code> will create a symlink to the relevant <code>latest_&lt;CAM_FC&gt;</code> directory. If you are archiving old baselines and do not want to create the symlink, use the <code>--no-symlink</code> flag.</p>"},{"location":"development/cam-testing/#adding-a-new-regression-test","title":"Adding a new regression test","text":"<p>The test list can be found here: <code>$CAM-SIMA/cime_config/testdefs/testlist_cam.xml</code></p> <ul> <li>If you are adding a new machine, compiler or category for an existing test, add a new <code>&lt;machine&gt;</code> XML entry to that <code>&lt;test&gt;</code> entry</li> <li>If you are adding a fully new test, add a new <code>&lt;test&gt;</code> XML entry with the following structure:</li> </ul> <pre><code>&lt;test compset=\"&lt;COMPSET_NAME&gt;\" grid=\"&lt;GRID_ALIAS&gt;\" name=\"&lt;TEST_TYPE&gt;_&lt;TEST_MOD&gt;\" testmods=\"&lt;RELPATH_TO_TESTMODS_DIR&gt;\"&gt;\n  &lt;machines&gt;\n    &lt;machine name=\"&lt;MACH_NAME&gt;\" compiler=\"&lt;COMPILER&gt;\" category=\"&lt;TEST_CATEGORY&gt;\"/&gt;\n  &lt;/machines&gt;\n  &lt;options&gt;\n    &lt;option name=\"comment\"&gt;COMMENT HERE&lt;/option&gt;\n    &lt;option name=\"wallclock\"&gt;WALLCLOCK_TIME&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/test&gt;\n</code></pre> <ul> <li><code>&lt;COMPSET_NAME&gt;</code>: component set alias (or long name) - you can see more about compsets here</li> <li><code>&lt;GRID_ALIAS&gt;</code>: model grid/resolution you'd like to run on - you can see more about grids here<ul> <li>Try to use the lowest/coarsest resolution that will still accomplish your testing goals</li> </ul> </li> <li><code>&lt;TEST_TYPE&gt;</code>: type of test to be run. You can find the testing types here.</li> <li><code>&lt;TEST_MOD&gt;</code>: test modifier that changes the default behavior of the test type. More here<ul> <li>Unless a longer run is necessary to exercise the code you are testing, run for 9 timesteps (_Ln9)</li> </ul> </li> <li><code>&lt;RELPATH_TO_TESTMODS_DIR&gt;</code>: relative path to the testmods directory for this run; usually looks something like <code>\"cam/some_directory_name/\"</code><ul> <li>The testmods directory will contain any namelist mods and XML configuration variable changes for the test (<code>user_nl_cam</code> and/or <code>shell_commands</code>)</li> <li>testmods directories can be found in <code>$CAM-SIMA/cime_config/testdefs/testmods_dirs/cam/</code></li> </ul> </li> </ul> <p>standard snapshot test mods</p> <p>All new test mod directories will likely include a mod to CAM_CONFIG_OPTS in <code>shell_commands</code> as well as the following mods to <code>user_nl_cam</code>:</p> <ul> <li><code>ncdata</code> (initial data file - the \"before\" snapshot)</li> <li><code>ncdata_check</code> (check file - the \"after\" snapshot)</li> <li><code>ncdata_check_err=.true.</code> (will cause the test to fail if the ncdata check process fails)</li> <li><code>min_difference=&lt;some small number&gt;</code> (if your ncdata_check had roundoff errors, set this to a number slightly above your roundoff)</li> <li><code>pver=30</code> (to match your snapshot file)</li> <li>Some relevant history fields for baseline comparisons - see history usage</li> </ul> <ul> <li><code>&lt;MACH_NAME&gt;</code>: machine name (options: <code>derecho</code>, <code>izumi</code>, <code>casper</code>)</li> <li><code>&lt;COMPILER&gt;</code>: compiler to be used (options: <code>gnu</code>, <code>nag</code>, <code>intel</code>, <code>nvhpc</code>)</li> <li><code>&lt;TEST_CATEGORY&gt;</code>: group of tests that this test belongs to - the default run by <code>test_driver.sh</code> is <code>aux_sima</code> (which is run for each PR to CAM-SIMA)</li> <li><code>WALLCLOCK_TIME</code>: maximum amount of time that the job will be allowed to run</li> </ul> <p>Here is an example test entry for a 2-timestep smoke test of kessler physics on a coarse MPAS grid, run with both intel and gnu </p> <pre><code>  &lt;test compset=\"FKESSLER\" grid=\"mpasa480_mpasa480\" name=\"SMS_Ln2\" testmods=\"cam/outfrq_kessler_mpas_derecho_nooutput/\"&gt;\n    &lt;machines&gt;\n      &lt;machine name=\"derecho\" compiler=\"intel\" category=\"aux_sima\"/&gt;\n      &lt;machine name=\"derecho\" compiler=\"gnu\" category=\"aux_sima\"/&gt;\n    &lt;/machines&gt;\n    &lt;options&gt;\n      &lt;option name=\"wallclock\"&gt;00:10:00&lt;/option&gt;\n      &lt;option name=\"comment\"&gt;GNU build test for MPAS dycore (with Kessler physics)&lt;/option&gt;\n    &lt;/options&gt;\n  &lt;/test&gt;\n</code></pre>"},{"location":"development/cam-testing/#github-continuous-integration-testing","title":"Github continuous integration testing","text":"<p>The following tests/linters are run automatically on pull requests to <code>develop</code> in github. You can see previous runs of the CI tests here</p>"},{"location":"development/cam-testing/#python-unit-testing","title":"Python unit testing","text":"<p>CAM-SIMA supports two kinds of python unit tests, <code>doctest</code> and <code>unittest</code> tests, both of which are part of the standard python library.  </p> <p>All <code>unittest</code> tests should  be in:</p> <p><code>CAM-SIMA/test/unit/python</code></p> <p>while all files used by the tests should be in:</p> <p><code>CAM-SIMA/test/unit/python/sample_files</code></p> <p>All <code>unittest</code> tests are automatically run via Github Actions whenever a Pull Request (PR) is opened, modified, or merged.  </p> <p>All <code>doctest</code> tests are also run automatically as long as the scripts they are located in are under <code>CAM-SIMA/cime_config</code> or <code>CAM-SIMA/src/data</code>.</p> <p>To manually run all of the unit tests at any time, simply run the following shell script:</p> <p><code>CAM-SIMA/test/run_python_unit_tests.sh</code></p> <p>Finally, when adding new tests, determine if the test can be done in only a few lines with minimal interaction with external files or variables.  If so, then it would likely be best as a <code>doctest</code>.  Otherwise it should be a <code>unittest</code> test.  Failure to follow this rule of thumb could result in test failures in the Github Actions workflow.  Also remember to add your new tests to the <code>run_python_unit_tests.sh</code> script so future users can easily run the tests manually.</p>"},{"location":"development/cam-testing/#updating-sample-files","title":"Updating sample files","text":"<p>If you modified any python files in your code modifications (those in <code>cime_config</code> or in <code>src/data</code>), you may need to update the sample files to match what is now expected.</p> <ol> <li>Run the unit tests as described above</li> <li> <p>If you have failures, quickly check that the diffs are expected</p> <p><code>diff &lt;tmp file&gt; &lt;sample file&gt;</code></p> </li> <li> <p>Copy over the changed files from the <code>tmp</code> directory to the <code>sample_files</code> directory</p> </li> <li>Rerun the tests to confirm they all pass now.</li> </ol>"},{"location":"development/cam-testing/#static-source-code-analysis","title":"Static Source Code Analysis","text":""},{"location":"development/cam-testing/#python","title":"Python","text":"<p>Any python script which is added or modified via a PR will automatically be analyzed using <code>pylint</code>, and must have a score of 9.5 or greater in order to not be marked as a test failure.  The hidden <code>pylintrc</code> file used for the analysis can be found here:</p> <p><code>CAM-SIMA/test/.pylintrc</code></p> <p>Users can also manually run <code>pylint</code> against the core python build scripts by running the following shell script:</p> <p><code>CAM-SIMA/test/pylint_test.sh</code></p> <p>Please note that <code>pylint</code> is not part of the standard python library, and so it may need to be installed before being able to run the shell script.</p>"},{"location":"development/cam-testing/#git-fleximod-tests","title":"git-fleximod tests","text":"<p>git-fleximod CI tests are run on both the oldest supported (currently 3.8) and latest versions of python to confirm:</p> <ul> <li><code>bin/git-fleximod update</code> works on the existing <code>.gitmodules</code> file</li> <li>All module <code>url</code>s and <code>fxDONOTUSEurl</code>s match (e.g. a temporary fork was not committed)</li> <li>All module <code>fxtag</code>s exist and are in sync with submodule hashes<ul> <li>Also confirms that no <code>fxtag</code> is a branch</li> </ul> </li> <li>Spare checkout files exist</li> </ul> <p>If a test fails:</p> <ul> <li>View the run on github (either on the PR itself or in the actions tab)</li> <li>View the output under <code>Run $GITHUB_WORKSPACE/bin/git-fleximod update</code><ul> <li>Errors will be reported in course of the test execution <ul> <li>Compare with the last time the test succeeded to see what has changed</li> </ul> </li> <li>Errors may also be reported at the end of the execution</li> </ul> </li> <li>Update the <code>.gitmodules</code> file to fix any errors and push up your changes to the branch, at which time the tests will be rerun</li> </ul> <p>Run git-fleximod tests locally</p> <p>You can (somewhat) reproduce the git-fleximod test locally by running the following</p> <p><code>bin/git-fleximod update &amp;&amp;  bin/git-fleximod test</code></p> <p>Some example failures:</p> <p>URL does not match (no forks allowed!):</p> <pre><code>cice url https://github.com/peverwhee/CESM_CICE not in sync with required https://github.com/ESCOMP/CESM_CICE\n</code></pre> <p>Tags out of sync (may need to commit the updated module directory):</p> <pre><code>hemco hemco-cesm2_0_hemco_3_9_0 7bd8358 is out of sync with .gitmodules hemco-cesm2_0_hemco3_9_0\n</code></pre> <p>Sparse checkout file missing (check the path):</p> <pre><code>mpas sparse checkout file .mpas_sparse_checkout not found\n</code></pre>"},{"location":"development/debugging/","title":"Debugging techniques","text":"<p>Start with the CAM wiki.</p>"},{"location":"development/debugging/#cam-sima-specific-debugging","title":"CAM-SIMA-specific debugging","text":""},{"location":"development/debugging/#build-errors","title":"Build errors","text":"<p>Debugging tips if you get build errors:</p> <ul> <li>If the output indicates that the error message or failure is coming from somewhere within $CAM-SIMA/ccpp_framework:<ul> <li>If you're getting a clear error message, it's likely that you have something wrong with your metadata</li> <li>If you're getting an error message that indicates that something is breaking in the framework code itself (something went uncaught) - consult the AMP SEs</li> </ul> </li> <li>If the error happens during the atm build, you can see the full output of the atm build in the build log here: <code>bld/atm.bldlog.*</code></li> </ul>"},{"location":"development/debugging/#run-time-errors","title":"Run-time errors","text":"<ul> <li>Start with the atm.log* - if the issue occurred during the execution of the CAM code, it will hopefully have a clear and concise error message</li> <li>Move to the cesm.log* - it will hopefully include a stack trace for the error in question; if the error did not occur in the CAM code (or CAM did not properly trap the error), it will help you identify the source of the issue.</li> <li>If neither log file contains helpful information, a few first steps:<ul> <li>Resubmit the case; it could be a machine hiccup</li> <li>Turn on DEBUG mode (if it's not on already) and rebuild/rerun</li> <li>Look in your run directory for any log files called <code>PETXXX</code> - if there was an issue on the ESMF side of things, it will show up in one of these (there will be one PET file per processor)</li> <li>Try a different compiler - maybe it'll give you a more helpful error message</li> <li>set NTASKS=1 (<code>./xmlchange NTASKS=1</code>), do a clean rebuild (as instructed), and run again; maybe running in serial will identify the error</li> <li>Look for the <code>***************** HISTORY FIELD LIST ******************</code> in the atm.log* file; if it's not there, the error occurred at init time<ul> <li>If the error occurred during init time, try a new case with a different grid and/or dycore</li> <li>If the model ran for a few timesteps before dying (look for the <code>CAM-SIMA time step advanced</code> message in the atm.log* file), it's likely that one or more variable that you introduced or modified has gone off the rails (value has become very large or very small or zero)<ul> <li>Update your user_nl_cam to output all possible suspected variables to a history file at some point shortly before the model dies, then inspect the output to see if any are obviously wrong</li> </ul> </li> <li>If the model completed all timesteps, try running a shorter case to see if the problem persists; if so, it's an error during the model finalization</li> </ul> </li> <li>Run the TotalView debugger on izumi</li> <li>Use the old standard - print statements - to narrow down where the code is stopping</li> <li>Ask for help!</li> </ul> </li> </ul>"},{"location":"development/debugging/#unexpected-answer-changes","title":"Unexpected answer changes","text":"<ul> <li>Two paths here:<ul> <li>You're getting unexpected DIFFs from the regression testing<ul> <li>Consult with a scientist about whether differences are expected and for which configurations (compsets, resolutions, namelists parameters, etc)</li> <li>If the differences are very small (look like round-off), consult with the other AMP SEs on whether we're ok with this</li> <li>If the differences are indeed unexpected and larger than round-off, create a case using the code from the head of <code>development</code> and:<ul> <li>place print statements in both code bases (your development branch and the head of <code>development</code>) to identify where the numbers are going awry OR</li> <li>run the TotalView debugger OR</li> <li>use the comparison tool described below (<code>$CAM-SIMA/tools/find_max_nonzero_index.F90</code>)</li> </ul> </li> </ul> </li> <li>You're getting unexpected answer changes compared with CAM<ul> <li>Consult with other AMP SEs about whether the differences appear to be due to round-off error</li> <li>Use the comparison tool (LINK ONCE IT EXISTS): <code>$CAM-SIMA/tools/find_max_nonzero_index.F90</code><ul> <li>This tool can help you narrow down where the issue begins by printing out values at a specific index and comparing those with the \"truth\" (from CAM)</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"development/debugging/#totalview","title":"TotalView","text":"<ul> <li>Grab an interactive node. You can do this by copying the following commands into a .csh script:</li> </ul> <pre><code>#! /bin/csh -f\n#PBS -q long\n# Number of nodes (CHANGE THIS if needed)\n# #PBS -l walltime=6:00:00,nodes=1:ppn=16\n# # output file base name\n# #PBS -N test_dr\n# # Put standard error and standard out in same file\n# #PBS -j oe\n# # Export all Environment variables\n# #PBS -V\n</code></pre> <p>then run:</p> <pre><code>qsub -X -I &lt;script&gt;.csh\n</code></pre> <ul> <li>Create and configure a new case (using gnu and only 1 task)</li> </ul> <pre><code>./create_newcase --pecount 1 --case &lt;CASEDIR&gt; --compset &lt;COMPSET&gt; --res &lt;RESOLUTION&gt; --compiler gnu --run-unsupported\n</code></pre> <ul> <li>Turn on debug in the case <code>./xmlchange DEBUG=True</code></li> <li>Build the case (<code>./case.build</code>)</li> <li>Run command <code>bash</code> to change to bash (if not already)</li> <li>Run the following commands:</li> </ul> <pre><code>np=1\nnthreads=1\n\nsource .env_mach_specific.sh\n\nRUNDIR=`./xmlquery RUNDIR -value`\nEXEROOT=`./xmlquery EXEROOT -value`\nLID=`date '+%y%m%d-%H%M%S'`\n\ncd $RUNDIR\nmkdir timing\nmkdir timing/checkpoints\necho `pwd`\nexport OMP_NUM_THREADS=$nthreads\ntotalview ${EXEROOT}/cesm.exe\n</code></pre> <ul> <li><code>exit</code> to exit the totalview window and give up the node</li> </ul>"},{"location":"development/debugging/#gdb","title":"gdb","text":"<ul> <li><code>gdb</code> may be useful if you prefer a command-line interface for debugging.</li> <li>Similarly to TotalView, here are some basic set up tips for debugging:<ul> <li>Use <code>DEBUG=true</code>.</li> <li>Build using <code>NTASKS=1</code> and <code>NTHRDS=1</code>, so you do not have to debug in parallel.</li> <li>To more easily compare against CAM-SIMA, you can turn off chunking by specifying <code>-pcols &lt;number&gt;</code> in <code>CAM_CONFIG_OPTS</code> to be large enough to cover all columns.</li> <li>Use an interactive node; the environment can be set up by <code>source .env_mach_specific.sh</code> from the case directory.</li> <li>Run <code>gdb ../bld/cesm.exe</code> from the case run directory.</li> </ul> </li> <li>If comparing against CAM-SIMA:<ul> <li>Generate the snapshots CAM-SIMA will run on by running CAM first; then, disable snapshot output in CAM when running CAM in the debugger. If CAM is writing the snapshots at the same time CAM-SIMA is attempting to read them, you will get cryptic <code>NaN</code> in file read errors in CAM-SIMA.</li> <li>Remember that CAM snapshots start from the second timestep, so you have to skip the first set of whatever breakpoints you set in CAM to get to the first timestep CAM-SIMA runs.</li> </ul> </li> <li>Tips for <code>gdb</code>:<ul> <li>Set breakpoints using <code>break file_name.F90:line</code><ul> <li>Conditional breakpoints are useful if you want to break inside a loop; e.g., <code>break file_name.F90:123 if k == 26</code>.</li> <li>Save breakpoints using <code>save breakpoints &lt;file&gt;</code> and load them using <code>source &lt;file&gt;</code> when restarting <code>gdb</code>.</li> <li>Best locations for breakpoints for inspecting both CAM and CAM-SIMA are probably within the scheme itself; there you can inspect if the input variables coming into the scheme actually match each other (if not, then you may have to walk back to the previous scheme in the SDF to see where divergence started.)</li> <li>While it may be easy to inspect physics state in CAM (in a <code>_tend</code> subroutine or directly in <code>tphysbc</code>/<code>tphysac</code>) finding the equivalent location in the CCPP cap may not be easy.</li> <li>You can <code>info breakpoints</code> to see a list of breakpoints set, and show a count of how many # of times the breakpoints were triggered.</li> <li>If your breakpoints are hitting more often than expected but the timestep is not advancing, maybe it was accidentally set in a loop, or chunking was not disabled (for CAM).</li> </ul> </li> <li>Inspect variables using the <code>print</code> command; if differences are isolated in some columns, you can consult the results of \"Physics check data\" from CAM-SIMA or <code>cprnc</code> output of history files to find where the values are different; then you can print the variable at these columns (Fortran syntax will work, i.e., <code>print zi(2:5,25:26)</code>)</li> <li>A combination of breakpoints and watchpoints will help isolate where the CAM and CAM-SIMA runs diverge, then you can <code>backtrace</code> the exact call stack that lead to a specific variable diverging.</li> <li>If you need to \"go back in time\", Totalview on Izumi will be helpful!</li> </ul> </li> </ul>"},{"location":"development/git-basics/","title":"Working with git and GitHub","text":""},{"location":"development/git-basics/#getting-started-with-git","title":"Getting started with git","text":"<ul> <li>For a quick, visual introduction to git, try a 5 Minute Overview of Git on Youtube</li> <li>Need an introduction to version control along with git and GitHub? Try Git and GitHub for Poets, a Youtube series</li> <li>For a glossary of common terms used in git and GitHub documentation, see the GitHub glossary.</li> <li>GitHub's Git Handbook offers a brief overview of git and GitHub, including example workflows and links to more in-depth resources.</li> <li>Software Carpentry offers a hands-on introduction to git.</li> <li>A highly-regarded, comprehensive git reference is the book Pro Git (available as a book or a free pdf).<ul> <li>The first three chapters of Pro Git, along with sections 6.1 and 6.2 on GitHub, are particularly useful if you're getting started with git. [1]</li> <li>The site also contains links to git reference pages along with introductory videos on git.</li> <li>You can skip the last section of chapter 3, on rebasing, until you have more experience with git. It's easy to cause problems for yourself or others with rebasing so only use rebasing in CAM-SIMA following the workflow instructions below as rebasing rewrites history, which can make it impossible to reproduce exactly what you have done before.</li> </ul> </li> <li>For a clear introduction to git internals, try Dissecting Git Guts by Emily Xie.</li> <li>Git from the inside out is a blog post with accommpaning video from Mary Rose Cook that looks under the covers a bit to show what happens when you execute git commands.</li> <li>Git from the Bottom Up by Josh Wiegley provides a quick glossary of the main terms describing a git repository with links to detailed descriptions. Good site for reminders about a git concept.</li> <li>Need to really understand the science behind how git works? Try Advanced Git: Graphs, Hashes, and Compression, Oh My! by Matthew McCullough</li> </ul> <p>Git also offers extensive built-in (i.e., command line) help, although it can be hard to understand until you are familiar with basic git concepts:</p> <p><code>git help</code></p> <p><code>git help COMMAND</code></p> <p>man gittutorial</p> <p>man giteveryday</p>"},{"location":"development/git-basics/#how-to-set-up-your-git-development-environment","title":"How to set up your git development environment","text":"<p>There are several stages in setting up your git and GitHub development environment. Below, they are broken into three sections which represent the different stages:</p> <ul> <li>One time GitHub setup</li> <li>Set up git environment on new machine</li> <li>Working with clones</li> </ul>"},{"location":"development/git-basics/#one-time-github-setup","title":"One time GitHub setup","text":"<ol> <li>Set-up personal github account (if one does not already exist): https://github.com</li> <li> <p>Create a new personal CAM-SIMA fork of the ESCOMP/CAM-SIMA repo:</p> <p></p> </li> <li> <p>Set up SSH keys on GitHub (optional):</p> <p>If you will be pushing changes to GitHub (either to your own fork or to shared forks), or if you will be pulling changes from private repositories on GitHub, then it's worth the time to set up ssh keys for each machine you'll be using. By doing so, you won't have to enter your password when pushing to or pulling from GitHub.</p> <p>See here for instructions. After doing this, you can use the ssh form of GitHub URLs (e.g., <code>git@github.com:ESCOMP/cam-sima.git</code>) in place of the <code>https</code> form.</p> </li> <li> <p>Configure GitHub notifications (optional): It is important to keep track of activity on GitHub but there are ways to manage how you are notified.</p> <ul> <li>Controlling how you receive notifications: Click on your profile picture in the upper-right of any GitHub page, then click on \"Settings\", and then on \"Notifications\". You will see several options, here are a few recommended settings:<ul> <li>Automatically watch repositories: Yes (check box)</li> <li>Participating: Email</li> <li>Watching: Web</li> </ul> </li> <li>To see and manage Web notifications: Click on the bell in the upper right of any GitHub page to see Web notifications and to manage which repositories you are watching. There will be a blue dot on the bell if there are new (unread) notifications).</li> </ul> </li> </ol>"},{"location":"development/git-basics/#set-up-git-environment-on-new-machine","title":"Set up git environment on new machine","text":"<p>git has global settings which apply to all repository clones on your machine. These settings reside in a file called <code>.gitconfig</code> in your home directory. Below are some required and some optional but recommended global git settings to apply to any new machine where you will do CAM-SIMA development (e.g., Derecho, Izumi, personal laptop). Apply the settings below or simply copy a <code>.gitconfig</code> file from a machine that is already configured.</p>"},{"location":"development/git-basics/#required-git-global-configuration-settings","title":"Required git global configuration settings","text":"<pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email &lt;GitHub email address&gt;\n</code></pre> <p>We recommend that you use your UCAR email address as your GitHub email address but if you use another address, you can add your UCAR email address by clicking on your profile picture in the upper-right of any GitHub page, then clicking on \"Settings\", and then on \"Emails\".</p>"},{"location":"development/git-basics/#recommended-git-global-configuration-settings","title":"Recommended git global configuration settings","text":"<p>You can set which editor to use for log messages, etc., with:</p> <pre><code>git config --global core.editor &lt;editor of your choice: emacs, vi, vim, etc&gt;\n</code></pre> <p>(See http://swcarpentry.github.io/git-novice/02-setup for specific settings to use for many common editor choices.)</p> <p>The following setting generates better patches than the default:</p> <pre><code>git config --global diff.algorithm histogram\n</code></pre> <p>The following setting makes it easier to resolve conflicts if you're doing conflict resolution by hand as opposed to with a dedicated conflict resolution tool. Without this setting, you'll just see your version and the version you're merging in delimited by conflict markers. With this setting, you'll also see the common ancestor of the two sides of the merge, which can make it much easier to figure out how to resolve the conflict:</p> <pre><code>git config --global merge.conflictstyle diff3\n</code></pre> <p>Alternatively, look into using a graphical conflict-resolution tool such as kdiff3 or the Emacs built-in <code>M-x vc-resolve-coflicts</code>.</p> <p>We recommend that you set git to not push anything by default:</p> <pre><code>git config --global push.default nothing\n</code></pre> <p>This can help prevent you from accidentally pushing work to the wrong repository.</p>"},{"location":"development/git-basics/#configuring-git-on-shared-machines","title":"Configuring git on shared machines","text":"<p>If using git on shared resources, such as on the login nodes for CISL machines, then one may find their git commands being killed by sys admins due to git spawning too many threads and thus blocking (or at least slowing down) other users. To avoid this situation, you can limit the number of threads git spawns for various activities by setting the following git config variables:</p> <pre><code>git config --global --add index.threads 8\ngit config --global --add grep.threads 8\ngit config --global --add pack.threads 8\n</code></pre> <p>Please note that a limit of 8 threads was chosen specifically for CISL machines. If you are using a separate shared system you may find it beneficial to choose a different thread limit.</p>"},{"location":"development/git-basics/#git-tools-for-bash","title":"git tools for Bash","text":"<p>There are two helpful things you can do to streamline your use of git if you use the bash shell. These are completely optional, but improve your git experience. These are documented in the appendix of the excellent Pro Git book.</p>"},{"location":"development/git-basics/#updating-your-login-to-a-github-token","title":"Updating your login to a GitHub token","text":"<p>If you have been denied access to push to a GitHub repo, note that the old password system has been deprecated and no longer works. If you do not make changes, you will no longer be able to work with GitHub on personal forks and private repos.</p> <p>If you only ever git clone from public repositories like ESCOMP and ESMCI, you may ignore the rest of this wiki page.</p> <p>If you've already created and are using a GitHub token, you may ignore the rest of this wiki page.</p> <p>GitHub will soon be requiring that you use a GitHub generated token (basically a long password that they autogenerate for you).</p> <ol> <li>If you are on a Mac and do not need to use your password, but still receive an error message, you may have stored your password in the keychain. Remove a password on Macs</li> <li>Create a GitHub password token. Make sure you copy it to a safe place as they only show it to you once.</li> <li> <p>Store your credentials on every machine you use GitHub on.</p> <ul> <li> <p>On a private / secure Linux system:</p> <p><code>git config --global credential.helper store</code></p> </li> <li> <p>Note that the <code>store</code> option to git's credential helper stores your GitHub token in plain text. If you are on a public machine, you should store your GitHub token in a password manager and use the credential cache mechanism to open command-line access to your GitHub repositories:</p> <p><code>git config --global credential.helper cache --timeout &lt;seconds&gt;</code></p> <p>where <code>&lt;seconds&gt;</code> is the number of seconds git 'remembers' your token. For example, to only have to enter your token once per day:</p> <p><code>git config --global credential.helper cache --timeout 86400</code></p> </li> <li> <p>On Windows:</p> <p><code>git config --global credential.helper wincred</code>     - On Macs (make sure you select the Mac tab in the middle of the window): see this documentation</p> </li> </ul> </li> <li> <p>On each machine, do a <code>git clone</code> of your personal repo. It will ask for your username and password. The password needs to be your saved token. You should only need to do this once.</p> </li> <li>To test that your credentials are successfully cached, do a new <code>git clone</code> of your personal repo. If it clones without asking for your username/password you are done.</li> </ol>"},{"location":"development/git-basics/#working-with-clones","title":"Working with clones","text":"<p>Here are some commands for creating and working with clones:</p>"},{"location":"development/git-basics/#create-a-new-clone","title":"Create a new clone","text":"<pre><code>git clone https://github.com/&lt;GitHub userid&gt;/CAM-SIMA\ncd CAM-SIMA\n</code></pre> <p>or</p> <pre><code>git clone git@github.com:&lt;GitHub userid&gt;/CAM-SIMA\ncd CAM-SIMA\n</code></pre> <p>where <code>&lt;GitHub userid&gt;</code> is your GitHub account login ID. Some useful options to the clone command are:</p> <ul> <li><code>--origin &lt;origin name&gt;</code>: A clone knows where it came from and by default, calls that location, \"origin\". You can change that name with the <code>--origin</code> option. This can come in handy when dealing with multiple upstream repositories. Change the clone directory name: By default, the clone is created in a directory with the same name as the repository. You can change this by adding a directory name to the clone command. Use the appropriate example below:</li> </ul> <pre><code>git clone https://github.com/&lt;GitHub userid&gt;/CAM-SIMA  &lt;clone_dir_name&gt;\ncd &lt;clone_dir_name&gt;\n</code></pre> <p>or</p> <pre><code>git clone git@github.com:&lt;GitHub userid&gt;/CAM-SIMA &lt;clone_dir_name&gt;\ncd &lt;clone_dir_name&gt;\n</code></pre>"},{"location":"development/git-basics/#checking-out-a-tag-or-switching-to-a-new-tag","title":"Checking out a tag or switching to a new tag","text":"<ul> <li>To check out a tag: </li> </ul> <pre><code>git checkout &lt;tag&gt;\n</code></pre> <p>note that <code>&lt;tag&gt;</code> can also be the name of a branch or a commit hash. If you specify the name of a branch, you will check out the head of the branch. If you name a remote branch (e.g., <code>origin/branch_name</code>), you will create a detached HEAD but you can still use the code. Please note that if you plan on changing the code, first create a branch (see Working with branches)</p>"},{"location":"development/git-basics/#working-with-branches","title":"Working with branches","text":"<p>When you create a clone, your clone will contain pointers all the branches that existed at the clone's origin (e.g., the repository at GitHub). While you can check out these branches, however, before attempting to make any changes, you should first create a local version branch (so git can keep track of the local commits).</p> <ul> <li>To create a new local branch that starts at a certain point:</li> </ul> <pre><code>git branch &lt;new branch name&gt; &lt;tag or branch name&gt;\n</code></pre> <p>for example</p> <pre><code>git branch new_feature cam6_2_024\n</code></pre> <ul> <li>To check out a local branch:</li> </ul> <pre><code>git checkout &lt;new branch name&gt;\n</code></pre> <ul> <li>If you are working with a repository that uses <code>git-fleximod</code> (e.g., CAM-SIMA, CESM), always run that tool after checking out a new branch or tag:</li> </ul> <pre><code>bin/git-fleximod update\n</code></pre>"},{"location":"development/git-basics/#working-with-remotes-upstream-repository-locations","title":"Working with remotes (upstream repository locations)","text":"<p>While working with clones created using the methods above will be sufficient for most if not all of your development needs, there may be times when you will want to access or compare your code with code from a different repository. git has no problem storing revisions from multiple repositories in a single clone!</p> <p>To begin, your clone probably has a single remote (also known as an upstream repository). To see the current status of which upstream repositories are configured for your clone, use the <code>git remote</code> command:</p> <pre><code>git remote\n</code></pre> <p>To see the location of the remote repositories in your current directory:</p> <pre><code>git remote -v\n</code></pre> <p>You should see something like:</p> <pre><code>origin  https://github.com/gituser/CAM-SIMA (fetch)\norigin  https://github.com/gituser/CAM-SIMA (push)\n</code></pre> <p>This tells you the \"upstream\" location from where new code is downloaded (when you run <code>git fetch origin</code>) or where code is uploaded (when you run <code>git push origin &lt;branch&gt;</code>). Note that most <code>git</code> commands are purely local, using only information in the .git directory of your clone.</p> <p>You can rename an existing remote:</p> <pre><code>git remote rename origin ESCOMP\n</code></pre> <p>You can set the remote name as part of a clone command (the default is 'origin'):</p> <pre><code>git clone -o ESCOMP https://github.com/ESCOMP/cam-sima\n</code></pre>"},{"location":"development/git-basics/#adding-remote-new-upstream-repository-locations","title":"Adding remote (new upstream repository locations)","text":"<p>To add a new upstream repository, use the <code>remote add</code> command. For example:</p> <pre><code>git remote add ESCOMP https://github.com/ESCOMP/CAM-SIMA\ngit fetch --tags ESCOMP\n</code></pre> <p>You should see messages much like a new clone when you execute the <code>git fetch</code> command. Note that you can call the new remote anything, in this example we are calling it ESCOMP.</p>"},{"location":"development/git-basics/#updating-your-branch-to-latest-development","title":"Updating your branch to latest development","text":"<p>Note that while this section explains how to update your local branch to the <code>ESCOMP/CAM-SIMA/development</code> branch, the instructions can easily be generalized for any branch from any upstream remote.</p> <p>Before starting, you should have either:</p> <ul> <li>A fresh clone of your fork with the branch you wish to update checked out (see Create a new clone and Working with branches).</li> <li>An existing clone with the branch you wish to update checked out and in a clean state (i.e., make sure you do a <code>git commit</code> and that <code>git status</code> shows no modified files).</li> </ul> <p>Add the upstream remote, if you have not already done so (see Adding remotes).</p> <p>Merge the specific remote/branch into your branch. In this example, it is ESCOMP/development</p> <pre><code>git fetch ESCOMP\ngit merge ESCOMP/development\n</code></pre>"},{"location":"development/git-basics/#tagging-a-commit","title":"Tagging a commit","text":"<p>When a PR is ready to be merged into CAM-SIMA's code base, you will need to consider whether or not a new tag is appropriate. In CAM-SIMA, the standard is whether or not the baselines have changed since the last tag. After you have run the tests (per the regression testing workflow):</p> <ol> <li>If there are no baseline differences (no tests \"FAIL\" or yield a \"DIFF\"), no tag is necessary and you can proceed to SQUASH &amp; MERGE your PR (you will also not archive the baselines)</li> <li>If there are baseline differences (at least one test results in a \"DIFF\"), you will need to follow the procedure below to create a tag after you SQUASH &amp; MERGE your PR</li> </ol>"},{"location":"development/git-basics/#tag-syntax","title":"Tag syntax","text":"<p>We use the following syntax for CAM-SIMA tags: simaX_YY_ZZZ, where:</p> <ul> <li>X: major version; incremented only during major releases</li> <li>YY: minor version; incremented any time the answers for the CAM7 physics suite change (zero-padded)</li> <li>ZZZ: patch version; incremented when answers or fieldlists change for non-CAM7 configurations (zero-padded)</li> </ul> <p>To see the latest tag: https://github.com/ESCOMP/CAM-SIMA/tags.</p>"},{"location":"development/git-basics/#creating-a-new-tag","title":"Creating a new tag","text":"<ol> <li>Clone https://github.com/ESCOMP/CAM or update an existing clone with <code>git fetch &lt;escomp_remote&gt; development</code></li> <li>Find the PR merge commit (<code>&lt;merge_commit&gt;</code>) for the tag<ul> <li>In your up-to-date CAM clone, find the merge commit with <code>git log --oneline -1 &lt;escomp_remote&gt;/development</code> where the merge commit is the first field in the output.</li> </ul> </li> <li>Tag the <code>&lt;merge_commit&gt;</code> with <code>git tag -a &lt;tag&gt; &lt;merge_commit&gt; -m '&lt;commit_message&gt;</code> where <code>&lt;commit_message&gt;</code> is the same as the message for the <code>&lt;merge_commit&gt;</code></li> <li>Push the tag to the proper remote with <code>git push &lt;escomp_remote&gt; &lt;tag&gt;</code></li> </ol>"},{"location":"development/git-basics/#comparing-differences-using-git-diff","title":"Comparing differences using git diff","text":"<p>If you have a git clone, you can view differences between commits or tags. As far as <code>git diff</code> is concerned, a commit hash is the same as a tag so in the examples below will use <code>&lt;tag&gt;</code>.</p> <ul> <li>To see the full difference between two tags (i.e., a changeset):</li> </ul> <pre><code>  git diff &lt;tag1&gt; &lt;tag2&gt;\n</code></pre> <ul> <li>To see the full difference between the current checkout (sandbox) and a tag:</li> </ul> <pre><code>  git diff &lt;tag&gt;\n</code></pre> <ul> <li>To see only the names of files that are different:</li> </ul> <pre><code>  git diff --name-only &lt;tag&gt; [ &lt;tag2&gt; ]\n</code></pre> <ul> <li>To see the difference in one or more specific files:</li> </ul> <pre><code>  git diff &lt;tag&gt; [ &lt;tag2&gt; ] -- &lt;path_to_file1&gt; &lt;path_to_file2&gt;\n</code></pre>"},{"location":"development/git-basics/#configuring-and-using-a-graphical-difference-tool","title":"Configuring and using a graphical difference tool","text":"<p>git has a command, <code>difftool</code>, that can run a graphical tool on each file that is different between two commits.</p> <ul> <li>To configure <code>opendiff</code> as the graphical difference tool:</li> </ul> <pre><code>  git config --global diff.tool opendiff\n</code></pre> <ul> <li>To see the available graphical difference tools:</li> </ul> <pre><code>  git difftool --tool-help\n</code></pre> <ul> <li>To run <code>difftool</code> on <code>&lt;file1&gt;</code> and <code>&lt;file2&gt;</code></li> </ul> <pre><code>  git difftool &lt;tag&gt; [ &lt;tag2&gt; ] -- &lt;path_to_file1&gt; &lt;path_to_file2&gt;\n</code></pre> <ul> <li>To optionally run <code>difftool</code> on all files in a changeset (answer 'y' or 'n' for each file):</li> </ul> <pre><code>  git difftool &lt;tag&gt; [ &lt;tag2&gt; ]\n</code></pre> <ul> <li>To run <code>difftool</code> on all files in a changeset (i.e., same as 'y' for every file):</li> </ul> <pre><code>  yes | git difftool &lt;tag&gt; [ &lt;tag2&gt; ]\n</code></pre>"},{"location":"development/git-basics/#using-diffmerge","title":"Using <code>diffmerge</code>","text":"<p>This section contains the complete modifications needed for using the graphical tool diffmerge for \"git difftool\" and \"git mergetool\"</p> <p>There is a tool called <code>diffmerge</code> which enables both side-by-side comparison of edited files in git as well as providing a three way-pane for editing merge conflicts. This tool is available for download at: https://sourcegear.com/diffmerge/. It has been installed on izumi and derecho by the system administrators in public areas, so you don't need to download it for those machines.</p> <p>To use the differencing tool type: <code>git difftool</code></p> <p>If after a <code>git merge</code> the git command says there are conflicts, then you may type <code>git mergetool</code> to allow you to resolve the conflicts and complete the merge. The mergetool with diffmerge properly installed will display three panes. From left to right these panes are: </p> <pre><code>Code being merged in          Merged code               Your code\n</code></pre> <p>The panes are opened in a visual editor, and any changes you make in the middle pane, may be saved by selecting the save icon at the top of the screen and then exiting the window. This will finalize the merge for that particular file.</p> <p>For a presentation which can be used as a tutorial, you may refer to: Presentation on diffmerge tool for git</p> <p>The following modifications may be copy/pasted into the user's <code>.gitconfig</code> file which resides in the home directory. Since the potential for making an editing mistake is possible, it is recommended that a copy be made of the <code>.gitconfig</code> file prior to these edits in case an error is discovered.</p> <p>If you have problems, check out the tips at the bottom of this page</p> <pre><code>[diff]\n\u00a0 \u00a0 \u00a0 \u00a0 tool = diffmerge\n\u00a0 \u00a0 \u00a0 \u00a0 algorithm = histogram\n[difftooldiffmerge]\n\u00a0 \u00a0 \u00a0 \u00a0 cmd = diffmerge \\\"$LOCAL\\\" \\\"$REMOTE\\\"\n[difftool \"diffmerge\"]\n\u00a0 \u00a0 \u00a0 \u00a0 cmd = diffmerge \\\"$LOCAL\\\" \\\"$REMOTE\\\"\n[difftool]\n\u00a0 \u00a0 \u00a0 \u00a0 prompt = false\n[push]\n\u00a0 \u00a0 \u00a0 \u00a0 default = simple\n[merge]\n\u00a0 \u00a0 \u00a0 \u00a0 tool = diffmerge\n\u00a0 \u00a0 \u00a0 \u00a0 ff = false\n[mergetool \"diffmerge\"]\n\u00a0 \u00a0 \u00a0 \u00a0 cmd = diffmerge --merge --result=$MERGED $REMOTE $BASE $LOCAL\n[mergetool]\n\u00a0 \u00a0 \u00a0 \u00a0 keepBackup = false\n</code></pre> <p>Useful tips</p> <ul> <li>On derecho, if you get an error message about diffmerge not being loaded, make sure you are using <code>ncarenv/23.09</code> or newer (to check say \"module list\")</li> <li>If you do not get a response when clicking on the \"git mergetool\" window, make sure you find the \"conflict\" popup and hit \"exit\" on it</li> <li>If your git mergetool gives blank windows and says: \"Files are identical or equivalent under the current RuleSet\", hit OK and then go to the File dropdown menu and select \"Reload\". This filled in the blank windows for the user with this error. <ul> <li>CAUTION: Check your file carefully if you do this, as a second user who did this discovered that all of the changes which were automatically merged did not reside in the final saved version.</li> </ul> </li> </ul>"},{"location":"development/git-faq/","title":"git &amp; GitHub FAQ","text":""},{"location":"development/git-faq/#q-how-can-i-clone-someones-git-clone-to-my-directory-on-the-same-machine","title":"Q: How can I clone someone's git clone to my directory on the same machine?","text":"<p>A: <code>git clone &lt;path_name&gt; [&lt;local_dir&gt;]</code> where <code>&lt;path_name&gt;</code> is the location of the source git clone and the optional <code>&lt;local_dir&gt;</code> is the name of the clone (default is a local directory of the same name as the original).</p>"},{"location":"development/git-faq/#q-how-can-i-clone-someones-git-clone-to-my-directory-on-a-different-machine","title":"Q: How can I clone someone's git clone to my directory on a different machine?","text":"<p>A: <code>git clone ssh://&lt;user&gt;@&lt;machine&gt;:&lt;path_name&gt; [&lt;local_dir&gt;]</code> where <code>&lt;user&gt;</code> is your user name on the remote machine, <code>&lt;machine&gt;</code> is the machine name (e.g., derecho.hpc.ucar.edu), <code>&lt;path_name&gt;</code> is the location of the source git clone on the remote machine, and the optional <code>&lt;local_dir&gt;</code> is the name of the clone (default is a local directory of the same name as the original).</p>"},{"location":"development/git-faq/#q-how-can-i-look-at-someones-pr-code","title":"Q: How can I look at someone's PR code?","text":"<p>A: There a a few ways to do this:</p> <ul> <li>On GitHub (like looking at any other code on GitHub)</li> <li>Add the PR fork to my remote (allows using tools such as <code>git diff</code> or <code>git difftool</code> with your existing branches or <code>development</code>)</li> <li>As a clone (standalone clone on your machine).</li> </ul> <p>A first step is to find the link to the fork's branch. Just below the PR is a line that starts with a colored oval (e.g., \"Open\" in green) and looks something like:</p> <pre><code>Octocat wants to merge 123 commits into ESCOMP:development from Octocat:amazing-new-feature\n</code></pre> <p>Clicking on the last part (<code>Octocat:amazing-new-feature</code>) will take you to the correct branch where you can browse the code (the first method above). If you want to download that code, click the green \"Code\" button and then click the clipboard icon. Be sure to take note of the branch name.</p> <ul> <li>To load this code into your clone, cd to your clone directory, add the PR fork as a new remote, and checkout the branch. For instance:</li> </ul> <pre><code>    git remote add octocat https://github.com/octocat/CAM-SIMA.git\n    git fetch --no-tags octocat\n    git checkout octocat/amazing-new-feature\n</code></pre> <p>Instead of the <code>checkout</code> you can also do diffs:</p> <pre><code>    git difftool origin/development octocat/amazing-new-feature\n</code></pre> <ul> <li>If you want to make a new clone with the PR code, simply do:</li> </ul> <pre><code>    git clone -b amazing-new-feature octocat https://github.com/octocat/CAM-SIMA.git octocat_cam\n    cd octocat_cam-sima\n</code></pre>"},{"location":"development/git-faq/#q-why-do-pull-request-pr-code-review-take-so-long","title":"Q: Why do Pull Request (PR) code review take so long?","text":"<p>A: A code review must fulfill three purposes:</p> <ul> <li>Code reviewers must make sure that new and/or changed code does not affect any currently-supported functionality (i.e., it cannot break anything).<ul> <li>While regression tests will catch many of these issues, reviewers must also check for usage of or reliance on deprecated code, and also for any code which is not supported on all platforms and compilers used by the CESM community.</li> </ul> </li> <li>Code reviewers must make sure that any new functionality or changes are implemented correctly and at least somewhat efficiently. They must also ensure that important changes are tested against future regressions.</li> <li>The CAM SE team is almost always engaged in several projects to implement new CAM functionality along with supporting infrastructure. Each CAM SE usually looks at each PR in order to prevent new code from interfering with those plans.</li> </ul> <p>The first two steps are usually completed by a single SE although SEs engaged in a final review will often find missed errors. This is similar to peer reviewers finding problems with a paper even after reviews done by colleagues.</p>"},{"location":"development/git-faq/#q-how-do-i-update-my-branch-to-the-current-cam_development","title":"Q: How do I update my branch to the current cam_development?","text":"<p>A: see this section</p>"},{"location":"development/git-fleximod/","title":"git-fleximod","text":""},{"location":"development/git-fleximod/#populate-andor-update-your-externals","title":"Populate and/or update your externals","text":"<p>Run <code>bin/git-fleximod update</code></p> <p>The process will either:</p> <ul> <li>complete and you're good to go</li> <li>indicate to you that modifications have been made in certain modules<ul> <li>this means you should either go commit those mods or remove them</li> <li>you can also (if you're sure!) run <code>bin/git-fleximod update -f</code> to force overwrite all externals</li> </ul> </li> </ul>"},{"location":"development/git-fleximod/#update-external-repo-or-tag","title":"Update external repo or tag","text":"<p>To add or update an external repo to CAM-SIMA, the following steps must be done:</p> <ol> <li>Modify the <code>.gitmodules</code> file at the head of CAM-SIMA to add or update the external.  Explanations for what each entry in the <code>.gitmodules</code> file is can be found on Github here</li> <li>Once the <code>.gitmodules</code> file has been updated, go to the head of CAM-SIMA and run <code>bin/git-fleximod update</code>.  This will bring in the new external code into your local repo (but will not commit them).</li> <li>Once you are ready to officially commit the changes, then make sure to commit both the modified <code>.gitmodules</code> file, and the updated submodule itself.  An easy way to make sure you have commited everything is to run <code>git status</code> and make sure there are no files or directories that have been modified but are still un-staged.</li> </ol> <p>Once all of that is done then congrats!  A new external has been successfully added/updated.   </p>"},{"location":"development/tool-recommendations/","title":"Tool recommendations","text":"<p>This page lists recommendations for various tools one might use during CAM-SIMA development.</p> <p>Please note that these standards are currently in development, and thus any of them could change at any time.</p>"},{"location":"development/tool-recommendations/#version-control","title":"Version Control","text":"<p>The recommended version control tool is git.</p>"},{"location":"development/tool-recommendations/#repository-hosting","title":"Repository Hosting","text":"<p>We recommend Github for hosting software repositories</p>"},{"location":"development/tool-recommendations/#cicd","title":"CI/CD","text":"<p>When possible, we recommend running any CI/CD workflows using Github Actions.</p>"},{"location":"development/tool-recommendations/#container-software","title":"Container Software","text":"<p>We recommend using Docker for building and running containers.</p> <p>More to Come!</p>"},{"location":"usage/creating-a-case/","title":"Creating, configuring, and running a case","text":"<p>Because CAM-SIMA uses the CIME build system, creating and configuration a case is mostly the same as it was in CAM7 (and in CESM). But! We're going to assume you know nothing.</p>"},{"location":"usage/creating-a-case/#1-run-create_newcase","title":"1. Run <code>create_newcase</code>","text":"<p>Before you create a case:</p> <ol> <li>Choose the correct machine to run your case on (if this is a high-resolution or long run, you will likely want to choose derecho!)</li> <li>Consult the git basics if you need a new clone</li> <li>Make sure you have run <code>bin/git-fleximod update</code> to update and/or populate your externals</li> <li>Navigate to <code>$CAM-SIMA/cime/scripts</code></li> </ol> <p>Assuming you have completed the above steps and have a nice checkout of a development branch of CAM-SIMA, let's go!</p> <p>Here is the (basic) structure of the command for create_newcase:</p> <pre><code>./create_newcase --case &lt;CASEDIR&gt; --compset &lt;COMPSET_NAME&gt; --res &lt;RESOLUTION&gt; --compiler &lt;COMPILER&gt; --project &lt;PROJECT KEY&gt; --run-unsupported\n</code></pre> <p>To break that down piece by piece:</p> <ul> <li><code>--case &lt;CASEDIR&gt;</code> (optional): The <code>case</code> argument specifies the full path to the directory you would like to be created, in which your case will reside.<ul> <li>pro tip: if you choose to put your case directory in your scratch directory, your <code>run</code> and <code>bld</code> directories will be automatically placed within the case directory<ul> <li>on derecho, this means: <code>--case /glade/derecho/scratch/&lt;username&gt;/&lt;case_name&gt;</code></li> <li>on izumi, this means:   <code>--case /scratch/cluster/&lt;username&gt;/&lt;case_name&gt;</code></li> </ul> </li> <li>if you do not specify a case directory, it will default to your <code>$CAM-SIMA/cime/scripts</code> directory (and, eventually, your <code>run</code> and <code>bld</code> directories will default to a new directory in your scratch space)</li> </ul> </li> <li><code>--compset &lt;COMPSET_NAME&gt;</code> (required): the compset (or \"component set\") tells CIME which base-level configurations you want to run with (including model versions and input data sets)<ul> <li>The compset supplied to the <code>create_newcase</code> command can be either:<ul> <li>The long name of a compset OR</li> <li>The alias (if it exists) for the compset</li> </ul> </li> <li>Compset options and aliases can be found in here (<code>$CAM-SIMA/cime_config/config_compsets.xml</code>)</li> <li>The structure of a compset long name is <code>&lt;initialization time&gt;_&lt;atmosphere model&gt;_&lt;land model&gt;_&lt;sea-ice model&gt;_&lt;ocean model&gt;_&lt;river runoff model&gt;_&lt;land ice model&gt;_&lt;wave model&gt;</code><ul> <li>Additional context: for each of the seven model components of the compset configuration, there can be three different implementations:<ul> <li>active (prognostic, full): solves a complex set of equations to describe model's behavior (must solve all equations on a numerical grid)</li> <li>data: version that sends/receives same variables to/from other models, but read from files rather than computed from equations (reduces feedback within a system)</li> <li>stub: occupies the required place in the driver but does not send or receive data</li> </ul> </li> </ul> </li> </ul> </li> <li><code>--res &lt;RESOLUTION&gt;</code> (required): the resolution specifies both the dycore being run and the grid.<ul> <li>The structure of the resolution argument is: <code>&lt;atmosphere&gt;_&lt;ocean&gt;_&lt;mask&gt;</code></li> <li>The resolution determines the dycore:<ul> <li>A grid resolution that looks like \"ne*\" indicates that this is spectral element (SE) cube sphere grid (SE dycore)</li> <li>A grid resolution that looks like \"C*\" indicates that this is the FV3 (finite volume cubed sphere) dycore [not yet implemented in CAM-SIMA]</li> <li>A grid resolution that looks like \"mpasa*\" indicates that this is an MPAS (Model for Prediction Across Scales) grid (MPAS dycore) [work-in-progress in CAM-SIMA]</li> </ul> </li> <li>You can find the options for these model grid aliases in <code>$CAM-SIMA/ccs_config/modelgrid_aliases_nuopc.xml</code></li> <li>Most often, for testing CAM-SIMA, we use a coarse SE grid like <code>ne3pg3_ne3pg3_mg37</code> or <code>ne5_ne5_mg37</code></li> </ul> </li> <li><code>--compiler &lt;COMPILER&gt;</code> (optional): the compiler you wish to use<ul> <li>Options:<ul> <li>on derecho:<ul> <li>intel (default)</li> <li>gnu</li> <li>nvhpc</li> </ul> </li> <li>on izumi:<ul> <li>intel (default) - NOTE: intel is not to be trusted on izumi (it's a known-buggy version)</li> <li>gnu</li> <li>nag - NOTE: until the nag version is updated beyond 7.0, CAM-SIMA won't work with nag</li> </ul> </li> </ul> </li> </ul> </li> <li><code>--project &lt;PROJECT KEY&gt;</code>: a project key to charge to<ul> <li>Only needed on derecho</li> <li>You can see the project keys you can use here (click on your primary group)<ul> <li>You can also see how much of the allocation has been used/is left by navigating to Reports -&gt; Project Search and searching for the key</li> </ul> </li> </ul> </li> <li><code>--run-unsupported</code>: this flag is mostly in place to indicate to scientists that the configuration they're choosing to run is not scientifically supported.</li> </ul> <p>Given all that, let's say you run the following command on izumi (assuming you're this mysterious person \"courtneyp\"):</p> <pre><code>./create_newcase --case /scratch/cluster/courtneyp/kessler-ne5-gnu-0722 --compset FKESSLER --res ne5_ne5_mg37 --compiler gnu --run-unsupported\n</code></pre> <p>What will happen is that a new case directory will be created here: <code>/scratch/cluster/courtneyp/kessler-ne5-gnu-0722</code> that will be configured to run the FKESSLER compset (long name: <code>2000_CAM%KESSLER_SLND_SICE_SOCN_SROF_SGLC_SWAV</code>) with the SE dycore and the ne5 grid.</p>"},{"location":"usage/creating-a-case/#2-configure-the-case","title":"2. Configure the case","text":"<p>Navigate into your shiny new case directory and run <code>./case.setup</code></p> <p>From here, there are A LOT of configuration options. We'll highlight a few here that you'll use often.</p>"},{"location":"usage/creating-a-case/#xml-configurations","title":"XML configurations","text":"<p>Many configurable settings can be found within the env_*.xml files in your case directory. In order to protect again typos, it's not advised to edit those directly. Instead, you will run <code>./xmlchange</code> commands to alter those settings (and <code>./xmlquery</code> can give you the current setting). You can find additional information on the configurable xml variables here. A few to highlight:</p> <ul> <li><code>CAM_CONFIG_OPTS</code>: This is where we tell CAM-SIMA what physics scheme(s) we wish to run, as well as if we wish to run the <code>null</code> dycore.<ul> <li>FKESSLER will default to <code>--physics-suites kessler --analytic_ic</code>, which means we're running the <code>suite_kessler.xml</code> SDF with the SE dycore (with analytic initial conditions - no need to supply an ncdata initial conditions file)</li> <li>If you instead want to run a test with the null dycore, you'll want to change this with <code>./xmlchange CAM_CONFIG_OPTS = \"--physics-suites kessler --dyn none\"</code></li> <li>A list of all possible configuration options can be found at the bottom of this page, or here</li> </ul> </li> <li><code>CAM_LINKED_LIBS</code>: Hopefully, you won't have to change this often; however, if you are getting linking errors during your build, try turning off the linked libraries (<code>./xmlchange CAM_LINKED_LIBS=''</code>)</li> <li><code>DOUT_S</code>: This is the flag to archive log files of successful runs. During development, we advise turning this off so your log files don't disappear on you (<code>./xmlchange DOUT_S=False</code>)</li> <li><code>STOP_OPTION</code> &amp; <code>STOP_N</code>: How long you are going to run the model. If <code>STOP_N</code> is 8 and <code>STOP_OPTION</code> is \"ndays\", you are setting the model up to run for 8 days.<ul> <li>the options for <code>STOP_OPTION</code> are: 'nsteps', 'nseconds', 'nminutes', 'nhours', 'ndays', 'nmonths', 'nyears'</li> <li><code>STOP_N</code> is an integer</li> <li>NOTE: if you are running the ncdata_check with snapshot files, keep the number of timesteps you are running at or below the number of timesteps on the snapshot files</li> <li>NOTE #2: These configurations can be updated without rebuilding the case</li> </ul> </li> <li><code>DEBUG</code>: A flag to turn on debug mode for the run (runs without compiler optimizations) - this is very useful during development! It defaults to \"False\", so you can turn it on with <code>./xmlchange DEBUG=True</code></li> <li><code>RUNDIR</code>: this is the path to the <code>run</code> directory for your case. The <code>bld</code> directory will exist one level up.</li> </ul> <p>If you run <code>./xmlchange</code>, the output will tell you if you need to re-set up and/or do a clean build of your case.</p>"},{"location":"usage/creating-a-case/#namelist-configurations","title":"Namelist configurations","text":"<p>There are countless namelist configuration options. These can be modified by updating the <code>user_nl_cam</code> file in your case directory. Namelist options can be updated without rebuilding the case.</p> <ul> <li>How to configure the namelist for history/output</li> <li>Information on namelist reader generation</li> <li>You can see the full CAM6 list of namelist options here, keeping in mind that most of those options have not yet been ported to CAM-SIMA</li> </ul>"},{"location":"usage/creating-a-case/#3-build-the-case","title":"3. Build the case","text":"<p>Run <code>./case.build</code></p> <p>The console output will tell you the progress of the build. If you get to <code>MODEL BUILD HAS FINISHED SUCCESSFULLY</code>, hooray!</p> <p>Debugging tips</p>"},{"location":"usage/creating-a-case/#4-run-the-case","title":"4. Run the case","text":"<p>Run <code>./case.submit</code></p> <p>The job will be submitted to the system's queue. You can see the status of your job with the <code>qstat</code> command. Once it is finished, the log files will be in the <code>run</code> directory (unless it ran successfully AND your archiver is on)</p> <p>Debugging tips</p>"},{"location":"usage/creating-a-case/#current-cam_config_opts-options-in-cam-sima","title":"Current CAM_CONFIG_OPTS options in CAM-SIMA","text":"<p>The following is a list of all the allowed options that can be included in <code>CAM_CONFIG_OPTS</code>, what each option does, whether or not they are required (and if not what the default value is), and what config variable it maps to in the <code>ConfigCAM</code> code.</p> <ul> <li>physics-suites (required)<ul> <li>usage example: <code>--physics-suites cam7</code></li> <li>purpose:  Specifies what CCPP physics suite(s) will be built and made available for the given case.  More than one suite can be specified using a semi-colon, e.g. <code>cam4;cam7</code>.</li> <li>ConfigCAM variable:  <code>physics_suites</code></li> </ul> </li> <li>dyn (required)<ul> <li>usage example: <code>--dyn mpas</code></li> <li>purpose:  Specifies what dynamical core will be built and made available for the given case.</li> <li>ConfigCAM variable: <code>dyn</code></li> </ul> </li> <li>analytic-ic (optional)<ul> <li>useage example: <code>--analytic-ic</code></li> <li>purpose: Specifies whether Analytic Initial Conditions (IC) will be used for the given case.</li> <li>default value:  <code>False</code> (file-provided ICs will be used instead)</li> <li>ConfigCAM variable: <code>analytic_ic</code></li> </ul> </li> <li>dyn-kind (optional)<ul> <li>useage example: <code>--dyn-kind REAL64</code></li> <li>purpose: Specifies the precision used by the dycore for real-type variables.  Currently the only two options are <code>REAL64</code> for double precision and <code>REAL32</code> for single precision.</li> <li>default value:  <code>REAL64</code></li> <li>ConfigCAM variable: <code>dyn_kind</code></li> </ul> </li> <li>phys-kind<ul> <li>useage example: <code>--phys-kind REAL64</code></li> <li>purpose: Specifies the precision used by the physics for real-type variables.  Currently the only two options are <code>REAL64</code> for double precision and <code>REAL32</code> for single precision.</li> <li>default value: <code>REAL64</code></li> <li>ConfigCAM variable: <code>phys_kind</code></li> </ul> </li> </ul>"},{"location":"usage/history/","title":"History &amp; model output","text":""},{"location":"usage/history/#configuring-the-namelist","title":"Configuring the namelist","text":"<p>The syntax for updating a the configuration for a history file is:</p> <pre><code>&lt;namelist_option&gt;;&lt;volume&gt;: &lt;setting&gt;\n</code></pre> <p>Possible namelist options for your <code>user_nl_cam</code> (fields in grey have not been fully implemented):</p> <ul> <li><code>hist_add_inst_fields</code>: add instantaneous fields to a specified history file</li> </ul> <ul> <li>hist_add_avg_fields: add average fields to a specified history file</li> <li>hist_add_min_fields: add minimum fields to a specified history file</li> <li>hist_add_max_fields: add maximum fields to a specified history file</li> <li>hist_add_var_fields: add standard deviation fields to a specified history file</li> </ul> <ul> <li><code>hist_remove_fields</code>: remove a given field from a specified history file</li> <li><code>hist_file_type</code>: type of file (options are \"history\", \"satellite\", and \"initial_value\") - defaults to \"history\"</li> <li><code>hist_max_frames</code>: maximum number of samples written to a specified history file (after which a new one will be created)</li> <li><code>hist_output_frequency</code>: frequency with which to write samples to a specified history file (syntax is <code>&lt;integer&gt;*&lt;multiplier&gt;</code> like <code>3*nhours</code>)</li> <li><code>hist_precision</code>: precision of the specified history file (options are \"REAL32\" and \"REAL64\") - defaults to \"REAL32\"</li> <li><code>hist_write_nstep0</code>: logical for whether or not to write the nstep = 0 sample (defaults to .false.)</li> <li><code>hist_filename_template</code>: template filename for the specified history file<ul> <li>Defaults to \"%c.cam.%u.%y-%m-%d-%s.nc\" where \"%c\" is the case name, \"%u\" is the volume, \"%y\" is the year, \"%m\" is the month, \"%d\" is the day, and \"%s\" is the number of seconds since midnight GMT, with the timestamp itself representing the model time when the file is created.</li> </ul> </li> </ul> <p>Example Take the following sample <code>user_nl_cam</code>:</p> <pre><code>hist_output_frequency;h1: 5*ndays\nhist_max_frames;h1: 3\nhist_add_inst_fields;h1: U\nhist_add_inst_fields;h1: V, Q\nhist_precision;h1: REAL64\nhist_filename_spec;h1: my-history-file%m-%d\nhist_write_nstep0;h1: .false.\n</code></pre> <p>It will be parsed by <code>hist_config.py</code> and this will be the relevant section of atm_in:</p> <pre><code>&amp;hist_config_arrays_nl\n    hist_num_inst_fields = 3\n    hist_num_avg_fields = 2\n    hist_num_min_fields = 0\n    hist_num_max_fields = 0\n    hist_num_var_fields = 0\n/\n\n&amp;hist_file_config_nl\n    hist_volume = 'h0'\n    hist_avg_fields = 'T', 'Q'\n    hist_max_frames = 1\n    hist_output_frequency = '1*month'\n    hist_precision = 'REAL32'\n    hist_file_type = 'history'\n    hist_filename_spec = '%c.cam.%u.%y-%m-%d-%s.nc'\n    hist_write_nstep0 = .false.\n/\n\n&amp;hist_file_config_nl\n    hist_volume = 'h1'\n    hist_inst_fields = 'U', \u2018V\u2019, \u2018Q\u2019\n    hist_max_frames = 3\n    hist_output_frequency = '5*ndays'\n    hist_precision = 'REAL64'\n    hist_file_type = 'history'\n    hist_filename_spec = 'my-history-file%m-%d'\n    hist_write_nstep0 = .false.\n/\n</code></pre> <p>In plain English, a one-month run with these history configuration will result in a total of three files that will look something like these:</p> <ul> <li>my-history-file01-06.nc<ul> <li>This file will contain instantaneous output for U, V, and Q (eastward_wind, northward_wind, and water vapor)</li> <li>It will contain three frames, one at each of the following times:<ul> <li>0001-01-06 (time=5)</li> <li>0001-01-11 (time=10)</li> <li>0001-01-16 (time=15)</li> </ul> </li> </ul> </li> <li>my-history-file01-21.nc<ul> <li>This file will contain instantaneous output for U, V, and Q (eastward_wind, northward_wind, and water vapor)</li> <li>It will contain three frames, one at each of the following times:<ul> <li>0001-01-21 (time=20)</li> <li>0001-01-26 (time=25)</li> <li>0001-01-31 (time=30)</li> </ul> </li> </ul> </li> <li>.cam.h0a.0001-02-01-00000.nc<ul> <li>This file will contain averaged output for T and Q (air_temperature and water vapor)</li> <li>It will have one frame with the time calculated at the midpoint of the month</li> </ul>"},{"location":"usage/history/#adding-a-diagnostic-field-to-the-cam-sima-source-code","title":"Adding a diagnostic field to the CAM-SIMA source code","text":"<p>During init time, fields can be added to the possible field list with a call to <code>history_add_field</code>:</p> <p>history_add_field(diagnostic_name, description, vdim_name, avgflag, units, gridname, flag_xyfill, mixing_ratio)</p> Field Optional? Type Description diagnostic_name No string diagnostic name for the field - will be the name in netcdf output file description No string Description of the variable vdim_name No string vertical dimension: <code>horiz_only</code> for no vertical dimension (see note below this table); 'lev' for vertical_layer_dimension; 'ilev' for vertical_interface_dimension avgflag No string default average flag; options: 'avg', 'inst', 'min', 'max', 'var' (standard deviation) units No string variable units gridname Yes string gridname on which the variable's data is mapped (defaults to the physics grid) flag_xyfill Yes string fill value for variable values mixing_ratio Yes string constituent mixing ratio type ('wet' or 'dry'); not set to anything if not passed in <p>horiz_only</p> <p><code>horiz_only</code> is a variable, not a string. If you have a variable with only a horizontal dimension, include this use statement in your module: <code>use cam_history_support, only: horiz_only</code></p> <p>Example:</p> <pre><code>call history_add_field('Q', 'water vapor mixing ratio', 'lev', 'avg', 'kg kg-1', mixing_ratio='wet')\n</code></pre> <p>It's important to avoid adding calls to <code>history_add_field</code> to the CCPP-ized physics schemes (to keep them portable). Instead, create a new diagnostics scheme and place that in the <code>cam_diagnostics</code> folder of the atmospheric_physics repository. The <code>history_add_field</code> call will be in the <code>init</code> phase.</p>"},{"location":"usage/history/#outputting-a-diagnostic-field-to-the-cam-sima-source-code","title":"Outputting a diagnostic field to the CAM-SIMA source code","text":"<p>After init time, a variable's current values can be captured for output with a call to <code>history_out_field</code>:</p> <p>history_out_field(diagnostic_name, field_values)</p> Field Optional? Type Description diagnostic_name No string diagnostic name for the field - will cause an error if the diagnostic name was not added via history_add_field field_values No real variable values to be stored in the history buffer(s) <p>Example:</p> <pre><code>call history_out_field('Q', const_array(:,:,const_idx))\n</code></pre> <p>It's important to avoid adding calls to <code>history_add_field</code> to the CCPP-ized physics schemes (to keep them portable). Instead, create a new diagnostics scheme and place that in the <code>cam_diagnostics</code> folder of the atmospheric_physics repository. The <code>history_out_field</code> call(s) will likely be in the <code>run</code> phase.</p>"},{"location":"usage/history/#using-the-output","title":"Using the output","text":"<p>The output files can be found in your <code>run</code> directory. They are in netCDF format. </p> <p>See the ADF for lots that you can do with your results!</p> <p>A few useful commands for inspecting netCDF data:</p> <ul> <li>To output the header/metadata information for the file (includes list of variables on the file):</li> </ul> <pre><code>ncdump -h file.nc\n</code></pre> <ul> <li>To output the data for a specific variable on the file:</li> </ul> <pre><code>ncdump -v &lt;varname&gt; file.nc\n</code></pre> <ul> <li>To compare two files*:</li> </ul> <pre><code>cprnc &lt;file1_path&gt; &lt;file2_path&gt;\n</code></pre> <ul> <li>To get a slice of one file (subset of time samples):</li> </ul> <pre><code>ncks -F -d time,&lt;start time&gt;,&lt;end time&gt;,&lt;step&gt; &lt;snapshot_file&gt; &lt;output_file_name&gt;\n</code></pre> <p>Example to get time samples 3-5 from a file onto a new file called \"split-file.nc\":</p> <pre><code>ncks -F -d time,3,5,1 file.nc split-file.nc\n</code></pre> <ul> <li>To diff a variable between two files (and output the results to a new netcdf file):</li> </ul> <pre><code>ncdiff -v &lt;field_name&gt; -o &lt;output_file&gt; &lt;file1&gt; &lt;file2&gt;\n</code></pre> <p>*<code>cprnc</code> can be found:</p> <ul> <li>on derecho: <code>/glade/campaign/cesm/cesmdata/cprnc/cprnc</code></li> <li>on izumi: <code>/fs/cgd/csm/tools/cime/tools/cprnc/cprnc</code></li> </ul>"}]}